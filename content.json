{"meta":{"title":"花花世界博客","subtitle":"逗比的小码农","description":"我思故我在","author":"花花世界","url":"http://andlollipop.github.io"},"pages":[{"title":"","date":"2017-12-14T10:51:33.565Z","updated":"2017-12-13T05:08:38.157Z","comments":true,"path":"404/404.html","permalink":"http://andlollipop.github.io/404/404.html","excerpt":"","text":"404 - arao'blog"},{"title":"类别","date":"2017-12-13T08:07:17.000Z","updated":"2017-12-14T06:37:06.718Z","comments":true,"path":"categories/index.html","permalink":"http://andlollipop.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-12-14T06:34:16.000Z","updated":"2017-12-14T11:42:41.636Z","comments":true,"path":"tags/index.html","permalink":"http://andlollipop.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-12-14T06:36:46.839Z","updated":"2017-12-14T06:36:46.839Z","comments":true,"path":"about/index.html","permalink":"http://andlollipop.github.io/about/index.html","excerpt":"","text":"关于me一只学习Android的小菜鸟，欢迎分享知识。 From QQ：2414923649Email: 2414923649@qq.com"}],"posts":[{"title":"","slug":"UI绘制第二弹","date":"2017-12-15T10:20:50.807Z","updated":"2017-11-23T05:26:00.270Z","comments":true,"path":"2017/12/15/UI绘制第二弹/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/UI绘制第二弹/","excerpt":"","text":"上一章我们从setContentView为出发点研究了DecorView的创建过程和显示过程，本章将继续进行研究UI的绘制流程 ##正文上一章一步一步的走到了performTraversals方法，开启了View的绘制 private void performTraversals() { // cache mView since it is used so much below... final View host = mView; //将DecorView赋值给了host ......//一些简单的赋值 WindowManager.LayoutParams lp = mWindowAttributes; ..... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);（1） int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; // lp是否设置了权重，如果设置了则将measureAgain置为true if (measureAgain) { performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } layoutRequested = true; } final boolean didLayout = layoutRequested &amp;&amp; !mStopped; if (didLayout) { performLayout(lp, desiredWindowWidth, desiredWindowHeight);（2） } ...... boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) { ...... performDraw();（3） } } 在方法中分别调用了performMeasure、performLayout、performDraw方法，分别对应测量、布局、绘制。getRootMeasureSpec的作用就是得到根View的测量规格 private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } 要想知道measureSpec的值就需要知道rootDimension是什么，一步步可以查到rootDimension是ViewGroup.LayoutParams.MATCH_PARENT,它是通过mWindowAttributes得到，mWindowAttributes又是WindowManager.LayoutParams的对象 public LayoutParams() { super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); type = TYPE_APPLICATION; format = PixelFormat.OPAQUE; } 所以performMeasure向下传递的是EXACTLY模式的，ok，进入performMeasure方法 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 这里调用了DecorView的measure方法，因为DecorView没有这个方法，它会调用View里面的measure方法 public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) {//为View加入阴影的效果 Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } ...... if (forceLayout || needsLayout) { //这里将测量缓存起来，如果缓存中有的话就不进行测量 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } } ok,因为是第一次测量，所以要进入onMeasure方法，由于上面操作的是DecorView对象，所以在onMeasure方法也是调用DecorView的，因为DecorView不具有代表性，这里我们查看FrameLayout方法的onMeasure @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); for (int i = 0; i &lt; count; i++) {//对ViewGroup进行遍历，分别对子Child进行测量 final View child = getChildAt(i); //当child为空的时候则不走测量的操作 if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); } } //最后要调用setMeasureDimension来确定ViewGroup的大小，如果不调用则会报错 //但是平时我们写也不会报错因为我们调用了super.measure()方法，View有一个默认的实现 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); } ok,进入measureChildWithMargins()方法 protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);//调用子View的measure的方法，如果子View也为GroupView的时候将重复上述的操作 } ViewGroup对子View的测量有三个方法分别是measureChildWithMargins、measureChild、measureChildren，进入getChildMeasureSpec方法用来得到ViewGroup传给子View的测量规格 public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { case MeasureSpec.EXACTLY://当父View传过来的mode是Exactly //当子View的尺寸是确定值并且大于0时则传给子View的尺寸为Child尺寸，mode为EXACTLY if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //当child的尺寸为Match_parent的时候则将传给子View的尺寸为父View的尺寸，mode为EXACTLY } else if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.EXACTLY; //当Child的尺寸为Wrap_content的时候则传给子View的尺寸为父View的尺寸，mode为AT_MOST } else if (childDimension == LayoutParams.WRAP_CONTENT) { // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; ......下面的类似，不多说 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } tips: EXACTLY ：父容器已经测量出所需要的精确大小，这也是childview的最终大小 match_parent，精确值 ATMOST : child view最终的大小不能超过父容器的给的 wrap_content UNSPECIFIED: 不确定，源码内部使用 一般在ScrollView，ListView ok,View的测量方法就完了，performLayout、performDraw套路是一样的 我们在自定义View或者ViewGroup的时候不要在onMeasure方法里面用getWidth/getHeight/getMeasureWidth得到View的尺寸，因为在measure的最后会调用View的setMeasuredDimensionRaw方法 private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 所以只能在onMeasure方法之后使用getMeasureWidth方法，另外getWidth/getHeight则应该在onLayout方法之后 @ViewDebug.ExportedProperty(category = &quot;layout&quot;) public final int getWidth() { return mRight - mLeft; } 所以当布局确定了之后才能得到View的尺寸。 对上面来个总结： 当我们使用自定义View的时候最终调用setMeasuredDimession方法来保存自己的测量宽高 final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: /* Parent says we can be as big as we want. Just don&apos;t be larger than max size imposed on ourselves. */ result = Math.min(desiredSize, maxSize); break; case MeasureSpec.AT_MOST: // Parent says we can be as big as we want, up to specSize. // Don&apos;t be larger than specSize, and don&apos;t be larger than // the max size imposed on ourselves. result = Math.min(Math.min(desiredSize, specSize), maxSize); break; case MeasureSpec.EXACTLY: // No choice. Do what we are told. result = specSize; break; } return result; 当我们使用ViewGroup的时候 测量子view的规格大小measureChildWithMargins、measureChild、measureChildren 通过子view的规格大小来确定自己的大小 setMeasuredDimession 通过上面的学习，我们可以做出自己的流式布局，效果如下： 获取父容器设置的测量模式和大小 int iWidthMode = MeasureSpec.getMode(widthMeasureSpec); int iHeightMode = MeasureSpec.getMode(heightMeasureSpec); int iWidthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int iHeightSpecSize = MeasureSpec.getSize(heightMeasureSpec); 核心代码 if(iCurLineW + iChildWidth &gt; iWidthSpecSize){ //记录当前行的最大宽度，高度累加 measuredWith = Math.max(measuredWith,iCurLineW); measuredHeight += iCurLineH; //将当前行的viewList添加至总的mViewsList，将行高添加至总的行高List mViewLinesList.add(viewList); mLineHeights.add(iCurLineH); iCurLineW = iChildWidth; iCurLineH = iChildHeight; viewList = new ArrayList&lt;View&gt;(); viewList.add(childView); }else{ iCurLineW += iChildWidth; iCurLineH = Math.max(iCurLineH, iChildHeight); viewList.add(childView); } 最后一行需要进行换行操作 if(i == childCount - 1){ measuredWith = Math.max(measuredWith,iCurLineW); measuredHeight += iCurLineH; mViewLinesList.add(viewList); mLineHeights.add(iCurLineH); } 设置最终的大小 setMeasuredDimension(measuredWith,measuredHeight); 对子View进行布局 int cusTop = 0; int cusLeft = 0; for (int i = 0; i &lt; totalViews.size(); i++) { List&lt;View&gt; lineViews = totalViews.get(i); int lineHeight = mLineHeights.get(i); for (int j = 0; j &lt; lineViews.size(); j++) { View childView = lineViews.get(j); MarginLayoutParams layoutParams = (MarginLayoutParams) childView.getLayoutParams(); int childLeft = cusLeft + layoutParams.leftMargin; int childTop = cusTop + layoutParams.topMargin; int childRight = childLeft + childView.getMeasuredWidth(); int childBottom = childTop + childView.getMeasuredHeight(); childView.layout(childLeft, childTop, childRight, childBottom); cusLeft += childView.getMeasuredWidth() + layoutParams.leftMargin + layoutParams.rightMargin; } cusLeft = 0; cusTop += lineHeight; } 凡不能毁灭我的，必使我强大 共勉~","categories":[],"tags":[]},{"title":"","slug":"ui绘制_Paint篇","date":"2017-12-15T10:20:50.806Z","updated":"2017-11-28T11:39:41.313Z","comments":true,"path":"2017/12/15/ui绘制_Paint篇/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/ui绘制_Paint篇/","excerpt":"","text":"这里我们来学习一下Paint的使用，废话不多说，开始撸码 ##正文开始我们先要学习一下Paint的简单使用喽！ 设置画笔样式 .setStyle(Paint.Style style) Paint.Style.FILL :填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边 Paint.Style.STROKE ：仅描边 注意STROKE、FILL_OR_STROKE与FILL模式下外轮廓的位置会扩大 设置画笔宽度 .setStrokeWidth(float width) 设置画笔是否抗锯齿 .setAntiAlias(boolean aa) 设置线冒样式 .setStrokeCap(Paint.Cap cap) Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) 设置线段连接处样式 .setStrokeJoin(Paint.Join join) Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) 设置笔画的倾斜度 .setStrokeMiter(float miter) 清空画笔复位 .reset() 设置一个外来Paint画笔 .set(Paint src) 设置alpha值、颜色、ARGB .setAlpha(int a) .setColor(int color) 获取与设置是否使用抗锯齿功能 .isAntiAlias() 设置抗锯齿 setAntiAlias(boolean aa) 是否使用图像抖动处理 .isDither() 设置图像抖动，会使绘制出来的图片颜色更加平滑和饱满、图像更加清晰 .setDither(boolean dither) 设置绘制路径的效果 .setPathEffect(PathEffect effect) CornerPathEffect——圆形拐角效果 DashPathEffect——虚线效果 例 //画同一条线段,偏移值为15 paint.setPathEffect(new DashPathEffect(new float[]{20,10,50,100},15)); intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10； phase： 开始绘制的偏移值 ComposePathEffect ComposePathEffect先应用圆角特效,再应用虚线特效 SumPathEffect 将生成的两条特效路径合并 设置图形重叠时的处理方式 .setXfermode(Xfermode xfermode) 设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果 .setMaskFilter(MaskFilter maskfilter) 设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 .setColorFilter(ColorFilter colorfilter) 设置图像效果，使用Shader可以绘制出各种渐变效果 .setShader(Shader shader) 在图形下面设置阴影层，产生阴影效果 .setShadowLayer(float radius ,float dx,float dy,int color) radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 获取字符行间距 .getFontSpacing() 设置和获取字符间距 .setLetterSpacing(float letterSpacing) .getLetterSpacing() 是否有下划线和设置下划线 .isUnderlineText() .setUnderlineText(boolean underlineText) 获取与设置是否有文本删除线 .isStrikeThruText() .setStrikeThruText(boolean strikeThruText) 获取与设置文字大小 .getTextSize() .setTextSize(float textSize) 注意：Paint.setTextSize传入的单位是px，TextView.setTextSize传入的单位是sp 获取与设置字体类型 .getTypeface() .setTypeface(Typeface typeface) Android默认有四种字体样式：BOLD(加粗)、BOLD_ITALIC(加粗并倾斜)、ITALIC(倾斜)、NORMAL(正常)，我们也可以通过Typeface类来自定义个性化字体。 获取与设置文字倾斜 .getTextSkewX() .setTextSkewX(float skewX) 官方推荐值为-0.25，值为负则右倾，为正则左倾，默认值为0。 获取与设置文本对齐方式 .getTextAlign() .setTextAlign(Paint.Align align) 设置亚像素，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能 .setSubpixelText(boolean subpixelText) 动态折断或生成一行字符串 breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth) 获取文本的宽高，通过bounds的Rect拿到整型 void getTextBounds(char[] text, int index, int count, Rect bounds) void getTextBounds(String text, int start, int end, Rect bounds) 粗略获取文本的宽度 float measureText(String text) float measureText(CharSequence text, int start, int end) float measureText(String text, int start, int end) float measureText(char[] text, int index, int count) 精确计算文字宽度 int getTextWidths(String text, int start, int end, float[] widths) int getTextWidths(String text, float[] widths) int getTextWidths(CharSequence text, int start, int end, float[] widths) int getTextWidths(char[] text, int index, int count, float[] widths) 另外就是文字位置的解析，先了解一下FontMetrics的top，ascent，desent, bottom的属性 top = top线的y坐标 - baseline线的y坐标 bottom = bottom线的y坐标 - baseline线的y坐标 ascent = ascent线的y坐标 - baseline线的y坐标 desent = desent线的y坐标 - baseline线的y坐标 看图就能计算出下面的结论 baseline = center +（FontMetrics.bottom - FontMetrics.top）/2 - FontMetrics.bottom 知道这些我们能做什么，下图就可以搞出来","categories":[],"tags":[]},{"title":"","slug":"UI绘制_Paint高级渲染","date":"2017-12-15T10:20:50.805Z","updated":"2017-11-30T05:07:05.281Z","comments":true,"path":"2017/12/15/UI绘制_Paint高级渲染/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/UI绘制_Paint高级渲染/","excerpt":"","text":"上一篇讲解了Paint的基本使用，从初始化到绘制，学好了基本功接下来要开始Paint的高级渲染的部分在开始之前还是要留一下Paint的基本使用的地址 Paint的基本使用 http://www.jianshu.com/p/88d718d1945e 开始撸码~ ##正文先来看一下要搞的效果图 ok,在Android中提供了如下的渲染类 BitmapShader /** * TileMode.CLAMP 拉伸最后一个像素去铺满剩下的地方 * TileMode.MIRROR 通过镜像翻转铺满剩下的地方。 * TileMode.REPEAT 重复图片平铺整个画面（电脑设置壁纸） */ BitmapShader bitMapShader = new BitmapShader(mBitMap,Shader.TileMode.MIRROR,Shader.TileMode.MIRROR); LinearGradient /**线性渐变 * x0, y0, 起始点 * x1, y1, 结束点 * int[] mColors, 中间依次要出现的几个颜色 * float[] positions,数组大小跟colors数组一样大，中间依次摆放的几个颜色分别放置在那个位置上(参考比例从左往右) * tile */ LinearGradient linearGradient = new LinearGradient( 0, 0,800, 800, mColors, null, Shader.TileMode.CLAMP); RadialGradient RadialGradient mRadialGradient = new RadialGradient(300, 300, 100, mColors, null, Shader.TileMode.REPEAT); SweepGradient SweepGradient mSweepGradient = new SweepGradient(300, 300, mColors, null); ComposeShader ComposeShader mComposeShader = new ComposeShader(linearGradient, bitMapShader, PorterDuff.Mode.DST_IN); 使用起来非常的简单，首先我们就使用composeShader来实现第二张图的效果 //图像渲染 BitmapShader bitmapShader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); LinearGradient linearGradient = new LinearGradient(0, 0, width, height, Color.GREEN, Color.BLUE, Shader.TileMode.REPEAT); RadialGradient radialGradient = new RadialGradient(width / 2, height / 2, width / 2, new int[]{0xffff0000, 0xff00ff00, 0xff0000ff}, null, Shader.TileMode.CLAMP); SweepGradient sweepGradient = new SweepGradient(width / 2, height / 2, new int[]{0xffff0000, 0xff00ff00, 0xff0000ff}, null); //将图像渲染和环形渐变进行组合，组合的形式是增强 ComposeShader composeShader = new ComposeShader(bitmapShader, radialGradient, PorterDuff.Mode.MULTIPLY); mPaint.setShader(composeShader); //绘制矩形区域用于显示组合之后的效果 canvas.drawRect(0, 0, width, height, mPaint); 然后我们使用BitmapShader来实现放大镜的效果 得到放大后图片 //放大后的整个图片 Bitmap scaleBitmap = Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth() * factor, mBitmap.getHeight() * factor, true); bitmapShader = new BitmapShader(scaleBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); 设置圆形的放大镜并将BitmapShader设置给放大镜Drawable mShapeDrawable = new ShapeDrawable(new OvalShape()); mShapeDrawable.getPaint().setShader(bitmapShader); mShapeDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2); matrix = new Matrix(); 随着手指滑动，放大镜不断移动位置 //将放大镜的图片往相反的方向挪动 matrix.setTranslate(-x * factor + RADIUS, -y * factor + RADIUS); mShapeDrawable.getPaint().getShader().setLocalMatrix(matrix); //切出手势区域的位置的圆 mShapeDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS); invalidate(); 使用Android的渲染还能做好多的炫酷的效果，这里就不一一进行说明。","categories":[],"tags":[]},{"title":"Kotlin基础第一弹","slug":"Kotlin_第一弹","date":"2017-12-15T10:20:50.804Z","updated":"2017-12-15T10:24:35.906Z","comments":true,"path":"2017/12/15/Kotlin_第一弹/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/Kotlin_第一弹/","excerpt":"","text":"Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些&gt; 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##Kotlin集合集合无非是list集合和map集合，如下： val list = listOf(1, 2, 3, 4) val map = mapOf(1 to &quot;a&quot;, 2 to &quot;b&quot;, 3 to &quot;c&quot;) 是不是很简单，但它只能去遍历不能去操作，why?首先我们以list为例，点进去看一下它里面只有get、indexof、iterator方法，这也就决定了它的职责就是去遍历 那如果想进度读写操作,就需要去使用mutableListOf、mutableMapOf来创建集合了 既然我们创建了一个集合，我们就需要对于进行遍历，和java不同的是kotlin使用了in来遍历 for(i in list){ println(&quot;i=$i&quot;) } 也可以使用forEach list.forEach { println(&quot;it=$it&quot;) } 还有 list.forEachIndexed{ index,i-&gt; println(&quot;index=$index i=$i&quot;) } 等等。这时候我们可能会有疑问，forEach里面大括号里要写什么呢？其实它里面接受的是一个lamada表达式 @kotlin.internal.HidesMembers public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element) } 这里就需要说一下了，(T)-&gt;Unit表示接受一个T类型参数返回一个Unit类型的函数，Unit也就是java中void类型，我们在调用的时候需要传入{params-&gt;}这种式子，Kotlin规定当参数只有一个的时候可以不用写，默认是it,所以我们也可以这样写 list.forEach {item-&gt; println(&quot;item=$item&quot;) } 好了，list说完了，下面说说Map，我们在定义map的时候用到了to,其实是key to value的格式，to充当的是中缀表达式，我们也可以定义自己的中缀表达式 infix fun &lt;A,B&gt; A.with(that: B):Pair&lt;A,B&gt; = Pair(this,that) 这样我们就可以这样 val pair = 4 to &quot;d&quot; val (key,value) = pair; ok,集合就先到这里，更多操作可以实际去操作 ##Kotlin扩展函数 扩展属性扩展函数、扩展属性很简单，直接上例子 val String.lastChar: Char get() = get(length - 1) inline fun String.show(): Unit { println(&quot;String.show()&quot;) } 直接使用类名.方法即可，调用的时候就可以”lypop”.show() ##Kotlin函数kotlin函数有个特点就是可以设置默认值 fun test(a: Int = 1, str: String = &quot;&quot;) { print(&quot;test(a: Int = 1, str: String = \\&quot;\\&quot;)&quot;) } fun test(str: String = &quot;&quot;) { print(&quot;test(str: String = \\&quot;\\&quot;)&quot;) } fun test(a: Int = 1, b: Int = 2, str: String = &quot;&quot;) { print(&quot;test(a: Int = 1, b: Int = 2,str: String = \\&quot;\\&quot;)&quot;) } 当你调用test()会执行最匹配的方法fun test(str: String = “”)，在kotlin也有java的可变参数，只需要在方法写入vararg item: Int即可 ##Kotlin可为空这个比较简单，先上代码 val str: String? = null str?.length 下面的调用也可以使用str!!.length的样式，具体？的使用在之后会经常用到，多多体会就好，这里不做过多的赘述 ##Kotlin字符串的使用字符串的操作这里以分割来说一下 val str = &quot;com.lypop.android&quot; val list = str.split(&quot;.&quot;) if(list is List){ for(value in list){ println(&quot;value=$value&quot;) } } 就是这么简单的一些调用，当然还有一些其他复杂的操作，例如 val path = &quot;E:\\\\md_workspace\\\\Kotlin_collection.md&quot; val afterLast = path.substringAfterLast(&quot;.&quot;) //获取到md println(&quot;afterLast=$afterLast&quot;) val beforeLast = path.substringBeforeLast(&quot;:&quot;) println(&quot;beforeLast=$beforeLast&quot;) val missingValue = path.substringBeforeLast(&quot;?&quot;,&quot;missing value&quot;) //如果没有找到的话则返回第二个参数 println(&quot;missing Value=$missingValue&quot;) 是不是相比java的substring更加灵活了，当然对于这种字符串的操作会使用就可以了，当然不知道意思的话，可以进源码查看也可以百度最后在说两个比较常用的知识点 打印&amp;字符 println(&quot;\\$abc&quot;) println(&quot;&quot;&quot; ${&apos;$&apos;}abc &quot;&quot;&quot;) 使用正则表达式 val match = &quot;(.+)\\\\.(.+)\\\\.(.+)&quot;.toRegex() val matchResult = match.matchEntire(&quot;com.lypop.one&quot;) val list1:List&lt;String&gt;? = matchResult?.destructured?.toList() if(list1 != null){ for(str in list1){ println(&quot;str=$str&quot;) } } 至此，简单的Kotlin第一段就结束了，相对于java来讲使用起来更加的方便更加高效，快来试试吧！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]},{"title":"Kotlin学习第四弹","slug":"Kotlin_第四弹","date":"2017-12-15T10:20:50.803Z","updated":"2017-12-15T10:26:58.256Z","comments":true,"path":"2017/12/15/Kotlin_第四弹/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/Kotlin_第四弹/","excerpt":"","text":"Kotlin我们也学了一些基础，但怎么用我们还是不知道？今天我们从基础转向实战，在Android平台上开发Kotlin 因为这篇我们会讲到anko的知识下面贴出它的官网地址，感兴趣的可以单独去研究 https://github.com/Kotlin/anko/wiki ##调用第三方库使用Kotlin这里我们以ButterKnife为例，配置ButterKnife在Kotlin的环境 首先加入kotlin的classpath ext.kotlin_version = &apos;1.1.2-3&apos; repositories { jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.1&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; } 然后添加kotlin依赖 apply plugin: &apos;kotlin-android&apos; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; 最后加入ButterKnife依赖，这里需要注意的是另外也添加kapt插件 apply plugin: &apos;kotlin-kapt&apos; compile &apos;com.jakewharton:butterknife:8.6.0&apos; kapt &apos;com.jakewharton:butterknife-compiler:8.6.0&apos; 这样kapt会将ButterKnife的java代码转化为kotlin代码 至此环境就配置好了，当然你也可以在网上搜一搜，这里也就是做个笔记 ##使用anko库 ###Anko Dialog对于Anko的Dialog用的最多的也Toast的使用，在Anko中使用toast是相当的简单 fun open_toast(view: View){ toast(&quot;toast&quot;) longToast(&quot;long toast&quot;) } 然后就是AlertDialog的使用也是一看就会用的那种 fun open_alert(view: View){ alert(&quot;Hi,I&apos;m Roy&quot;,&quot;Have you tried turning it off and on again?&quot;){ yesButton { toast(&quot;yes&quot;) } noButton { toast(&quot;no&quot;) } }.show() //当然你也可以使用自定义的View alert{ customView{ editText() } } } 当然还有其它的弹框这里就不一一介绍，具体请看官方 ###Anko Intent相比之前的Intent来说Anko提供的更加的方便，使用如下 startActivity(intentFor&lt;AnkoActivity01&gt;(&quot;id&quot; to 5).singleTop()) 其他的一些使用如下： ###Anko Log对于Log，Anko解释AndroidSDK提供的Log也是非常的简单，尽管方法需要你传递标签参数，但使用起来也是非常的简单，当然你也可以使用AnkoLogger来消除这一点 实现AnkoLogger的方式 info(&quot;this is second log info&quot;) //这种带lambda表达式的这种会去计算Log.isLoggable(tag, Log.INFO)是否为true，为true的话才打印 info { &quot;this is third log info&quot; } 使用其对象的方式 val logWithASpecificTag = AnkoLogger(&quot;lypop&quot;) logWithASpecificTag.info { &quot;this is Log info&quot; } 第一种Tag默认是类名，第二种可以自定义其Tag ###Anko helper你可以在你的项目中使用帮助者来简化你的代码，例如Color、Dimen等，颜色透明度直接色值.opaque就可以，尺寸的话直接使用dip(dipValue)、sp(spValue)就可以。在这里面还有一个就是applyRecursively()用来控制子View的操作，如： verticalLayout { textView{ text = &quot;EditText01&quot; backgroundColor = 0xff000.opaque textSize = 14f } textView { text = &quot;EditText02&quot; backgroundColor = 0x99.gray.opaque textSize = 23f } }.applyRecursively {//如果是ViewGroup的话可以使用applyRecursively来为每个Child View进行设置 view -&gt; when(view){ is TextView -&gt; view.textColor = Color.RED } } ###Anko CoroutinesAnko还提供了协程的用来做一些耗时的操作，提供的操作为bg{},具体代码如下： async(UI){//UI线程 val data: Deferred&lt;MyBean&gt; = bg {//后台线程 // Runs in background MyBean() } showData(data.await()) //await方法将一直等待bg返回的数据 } 为了防止内存泄漏我们常会使用弱引用，在Anko中使用弱引用方法如下： val ref: Ref&lt;AnkoActivity05&gt; = this.asReference() async(UI){ //ref替代了this@AnkoActivity05 ref().showData() } ###Anko Layout那我们先来说一下普通写Android布局有啥缺点 它不是类型安全的和不是空安全 它迫使您为每个布局都编写相同的代码 在设备上解析xml浪费CPU时间和电池 最重要的是它不允许代码重用 那Kotlin不行吗?为什么还要用anko呢？ 官方解释说Kotlin那种是解决了不能编程生成UI，但是用Kotlin代码写出来的UI难以维护所以才出现了anko库，具体相应的代码还请看官网。（其实也没必要看，毕竟出来了一种库必然有其存在的原因） verticalLayout { padding = dip(30) button(&quot;say&quot;){ onClick {toast(&quot;Hello,${if (it is TextView) it.text else &quot;&quot;}&quot;) } } button(R.string.app_name) button{ textResource = R.string.app_name }.lparams { //如果指定了 lparams 但是没有指定 width 或者 height，那么默认是 “wrapContent” width = matchParent topMargin = dip(10) horizontalMargin = dip(5) } } Activity没有显示调用setContentView，anko会自动为Activity设置Content View 这里列举了button的三种创建形式和为其设置参数当然在Activity/Fragment也会使用xml布局，anko也为我们提供了简单的创建控件对象的方式 对象的名字就是控件的ID 使用find(R.id.name)也可以 可以看出这几种都比Android的findViewById要舒适的多 当然代码中还可能会有 include include&lt;View&gt;(R.layout.something) { backgroundColor = Color.RED }.lparams(width = matchParent) { margin = dip(12) } 自定义View inline fun ViewManager.myView(init: MyView.() -&gt; Unit): MyView { return ankoView({ MyView(it) }, 0, init) } class MyView(ctx: Context) : View(ctx) { fun test() { } } 使用的时候和上面使用方法一样直接用myView{} 但是非常遗憾的是没有预览界面，虽然anko提供了支持插件，但非常遗憾的是仅支持AndroidStudio2.4+ 这样我们就创建了一个简单的布局 fun Context.sendSMS(number: String, text: String = &quot;&quot;): Boolean { try { val intent = Intent(Intent.ACTION_VIEW, Uri.parse(&quot;sms:$number&quot;)) intent.putExtra(&quot;sms_body&quot;, text) startActivity(intent) return true } catch (e: Exception) { e.printStackTrace() return false } } ###Anko SQLite在之前使用SQLiteOpenHelper，通常调用getReadableDatabase（）或getWritableDatabase（），但是您必须确保在接收的SQLiteDatabase上调用close（）方法。如果您从多个线程中使用它，则必须了解并发访问。 所有这一切都很艰难。 这就是为什么Android开发人员不太喜欢默认的SQLite API，而是更喜欢使用相当昂贵的包装器，如ORMs。 Anko提供了ManagedSQLiteOpenHelper 可以无缝替代默认的,当操作完毕之后就会自动关闭，在使用的时候需要去继承ManagedSQLiteOpenHelper class MySqlHelper(ctx: Context = MyApplication.getApplication(), name: String? = &quot;db&quot;, factory: SQLiteDatabase.CursorFactory? = null, version: Int = 1) : ManagedSQLiteOpenHelper(ctx, name, factory, version) { 我们如果想让它成为线程安全的可以 companion object { @Volatile private var helper: MySqlHelper? = null fun getInstance(): MySqlHelper { if (null == helper) { synchronized(MySqlHelper::class) { if (null == helper) { helper = MySqlHelper() } } } return helper!! } } 然后我们就可以使用Anko提供的数据库操作了 fun queryAll(): List&lt;Gps&gt; = use { select(Gps.TABEL_NAME).exec { parseList(classParser&lt;Gps&gt;()) //查询使用parserXX方法需要存在查询字段的相应构造方法 } } fun queryLonAfter(id: Long): List&lt;Double&gt; = use { select(Gps.TABEL_NAME, Gps.LON).whereArgs(&quot;${Gps._ID} &gt; {id}&quot;, &quot;id&quot; to id) .exec { parseList(DoubleParser) } } fun deleteById(id: Long){ use { delete(Gps.TABEL_NAME, &quot;${Gps._ID} = {id}&quot;, &quot;id&quot; to id) } } fun updateById(id: Long) { use { update(Gps.TABEL_NAME, Gps.PROVIDER to &quot;lbs&quot;).whereArgs(&quot;${Gps._ID} = {id}&quot;, &quot;id&quot; to id).exec() } } 这里使用use来包裹，当里面的代码执行完毕就会自动关闭数据库 至此，Anko就讲解完毕，更多的内容还请阅读官方，Thanks♪(･ω･)ﾉ","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]},{"title":"Kotlin基础第三弹","slug":"Kotlin_第三弹","date":"2017-12-15T10:20:50.802Z","updated":"2017-12-15T10:25:49.872Z","comments":true,"path":"2017/12/15/Kotlin_第三弹/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/Kotlin_第三弹/","excerpt":"","text":"Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##Start ####kotlin委托机制委托模式也是代理模式是软件设计模式中的一项基本技巧，在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理 在java和Android用到委托机制在AOP里，在java中使用继承InvocationHandler接口的方法来实现代理，而在Android中则使用AspectJ的方式来实现。在这里我们来讲解一下Kotlin的委托模式 类委托也就是上面讲的委托模式定义，然而在Kotlin中实现起来更加的方便更加的灵活，如： class MyList(list: ArrayList&lt;String&gt;) : Collection&lt;String&gt; by list { } 这种也是替代继承的方式，直接使用by关键字就将Collection的方法委托给list对象 属性委托在Kotlin中Delegates类内置了三种委托的方法，分别是lazy、notNull()、observable(“”)、vetoable(“”)、Map形式 lazy 用于进行懒加载，即第一次使用的时候才执行初始化操作 //当使用的时候才进行初始化（线程安全的） val list: ArrayList&lt;String&gt; by lazy { ArrayList&lt;String&gt;() } notNull() 使用于那些无法再初始化阶段就确定属性值的场合 //初始化str,用于为空属性进行初始化的场景 var str: String by Delegates.notNull&lt;String&gt;() observable() 观察者和java的观察者模式差不多 //oldValue是变化之前的值 newValue最新的值 var str: String by Delegates.observable(&quot;&quot;){//初始值 property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) } vetoable（）带条件的委托机制，通过返回的true和false来确定oldValue是上一个还是最初的 //返回true和observable是一样的效果 var str1: String by Delegates.vetoable(&quot;&quot;){ property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) true } //返回false则标志oldValue永远为初始值 var str2: String by Delegates.vetoable(&quot;&quot;){ property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) false } Map 通过一种全新的赋值方法给类属性进行赋值 class User(val map: Map&lt;String,Any?&gt;){ val name: String by map val age: Int by map } val user = User(mapOf(&quot;a&quot; to 1)) 除此之外我们也可以自定义委托，具体定义可仿照notNull()委托 private class NotNullVar&lt;T: Any&gt;() : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return value ?: throw IllegalStateException(&quot;Property ${property.name} should be initialized before get.&quot;) } public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { this.value = value } } 你也可以设置可读的委托机制，继承ReadOnlyProperty类即可 ####kotlin lambda表达式首先先给出一个小例子 val action = {i: Int, j: Int -&gt; println(&quot;i=$i j=$j&quot;)}; action(1,2) 注意的是lambda表达式用{}包裹，箭头前面是参数的参数，箭头后面是函数体；从调用上来说比java简单并且优雅了许多，但是实际用途呢？我们可以为一个函数传一个lambda，如： fun lambdaTest(arg1: Int, arg2: Int, oper: (a: Int, b: Int) -&gt; Int): Int { var result: Int = Int.MIN_VALUE if (arg2 != 0) { result = oper(arg1, arg2) } return result } fun main(args: Array&lt;String&gt;) { lambdaTest(1, 2, { a: Int, b: Int -&gt; a / b }) 既然是传函数当然也可以传递一个函数进去，常使用::，这里延伸出函数的引用，另外还有属性的引用，这里 listOf(1, 2, 3).forEach(::println) var name = &quot;1&quot; val p = ::name p.set/get 当最后一个参数为lambda的时候，可以将大括号放在外面，如： lambdaTest(1, 2){ a: Int, b: Int -&gt; a / b } 用lambda表达式的情况还是挺多的，例如在集合中遍历等操作 val list = arrayListOf(1, 2, 3) list.forEach { value -&gt; } ####kotlin 运算符重载表达式 class Rmb(var num: Int) { operator fun plus(rmb: Any?) { } } 这样就可以使用Rmb(1) + Rmb(2)进行计算了，是不是很简单。这种操作和前面讲的中缀表达式一样，只不过中间的是运算符了而已 ####kotlin 注解与反射 Kotlin的注解和java是类似的，先确定注解的类型，然后确定生命周期 @Target(AnnotationTarget.FIELD, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION) @Retention(AnnotationRetention.SOURCE) annotation class Path 使用的话直接在class前 fun前面 @Path class UsePath(val p: String) { } Kotlin反射则通过 String::class.java String.javaClass 这两种方式来得到Class&lt;?&gt;对象，进一步可反射得到相应的属性和方法","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]},{"title":"Kotlin基础第二弹","slug":"Kotlin_第二弹","date":"2017-12-15T10:20:50.800Z","updated":"2017-12-15T10:25:15.681Z","comments":true,"path":"2017/12/15/Kotlin_第二弹/","link":"","permalink":"http://andlollipop.github.io/2017/12/15/Kotlin_第二弹/","excerpt":"","text":"Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##kotlin类对于类，我们先要说下在Kotlin中接口有啥特点 interface OnClickListener{ val name: String fun test(){ println(&quot;OnClickListener test&quot;) } fun action() } 和java的接口相比，kotlin的接口更加强大还可以写方法的实现，还有一个那就是接口open类型的可以被直接继承 class Child1 : OnClickListener,OnClickListener1{ override val name: String = &quot;&quot; override fun test() { super&lt;OnClickListener&gt;.test() } override fun action() { } override fun action1() { } } 当你需要在子类方法调用父类的方法的时候直接super即可 对于抽象类 abstract class ABParent{ abstract fun test() } class ABChild: ABParent(){ override fun test() { } } 也是直接可以继承的，里面的abstract方法默认是open修饰 对于普通类就需要给父类用open进行修饰才能进行继承，因为对于类来说默认是final类型的，接下来我们就需要对类进行一些研究，对于java类分为内部类、外部类、静态类等等，kotlin当然也会有区分 class ClassA{ var name: String = &quot;lypop&quot; class NestClass{ fun test(){ //name = &quot;&quot; 嵌套类不能访问外部类的属性和方法 } } //内部类 存在外部类的引用 可以访问外部类的属性和方法 inner class InnerClass{ fun test(){ name = &quot;change Name&quot; } } //创建伴生对象 companion object { var comName = &quot;aaa&quot; fun companionTest(){ println(&quot;companionTest&quot;) } } //定义静态内部类 object InnerStaticClass{ fun test(){ comName = &quot;===&quot; } } } //定义静态外部类 object StaticOuterClass{ val age: Int = 22 } 这里我们需要注意： 嵌套类不能访问外部类的属性和方法,内部类才可以访问 因为kotlin没有static关键字，如果要在类中定义静态的方法和属性需要来创建伴生对象，在使用的时候可以ClassA.companion.comName也可以直接ClassA.comName访问 静态内部类可以访问伴生对象的属性和方法，就和java中静态内部类可以访问外部类定义的静态属性和静态方法是一样的 接下来一个便是匿名内部类的写法 val obj = object: OnClickListener2{ override fun test() { println(&quot;object test()&quot;) } } 该内部类实现了OnClickListener2的接口，将对象赋值给了obj 最后也就是Kotlin的数据类，和java中的Bean类一样，只有类属性和相应的get/set方法 data class Person(val name: String) ##kotlin类构造方法类的构造方法和java有些不同，kotlin分为主构造方法和次构造方法 class User(name: String) {//主构造方法 var name: String = &quot;&quot; var pwd: String = &quot;&quot; //次构造器 constructor(name: String, pwd: String) : this(name) { this.name = name this.pwd = pwd } //初始化器 init { this.name = name } } 这里需要注意的是： 次构造方法必须要去初始化主构造方法 当主构造方法需要权限等修饰的时候constructor必须要加上，其他的情况可以不写 对于初始化字段可以放在init初始化器中进行初始化 至此，Kotlin的第二讲完了，每天的坚持，总有一天会获得收获。 ~ 共勉","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]},{"title":"Kotlin_mvp_dagger2_retrofit","slug":"Kotlin_mvp_dagger2_retrofit","date":"2017-12-12T11:03:25.387Z","updated":"2017-12-15T10:28:49.033Z","comments":true,"path":"2017/12/12/Kotlin_mvp_dagger2_retrofit/","link":"","permalink":"http://andlollipop.github.io/2017/12/12/Kotlin_mvp_dagger2_retrofit/","excerpt":"","text":"上一篇我们学习了anko库的使用，到这里我们来做一个简单的小项目吧！那使用什么架构来写呢，这里我们使用Kotlin+dagger2+retrofit+MVP架构来撸码 在学习这篇文章之前需要掌握下面的知识，如下： dagger2 http://www.jianshu.com/p/39d1df6c877d retrofit http://www.jianshu.com/p/308f3c54abdd API http://gank.io/api ##正文因为项目中用的Dagger2比较多，这里来讲解一下项目中用到的几个注解，更多的详情可以看上面的地址 Component:组件、管理器、注入器功能就是将类中使用@Inject标记的属性和在对应属性类中使用@Inject标记的构造方法，然后将它们关联起来。 而如果构造方法需要参数，或者我们没法再需要注入的对象的构造方法加入@Inject注解的时候就需要使用Module 该注解里面的参数有两个，一个是设置modules所关联的Module类，第二个是dependency所依赖的Component Module：提供者、依赖对象工厂功能是与被@Inject标记的构造方法一样提供生成依赖的对象 因为对于第三方库我们没有办法将它的构造方法加入@Inject标记，这时候我们需要使用Module生成，并提供@provide注解，Component会去查找Module类中@provide的方法获取到对象并通过component返回目标类需要的对象并注入到目标类 Qualifier:限定符功能是在同一纬度下存在多个依赖对象的提供方式(多个构造方法)，则会迷失。这时，可以使用Qualifier 提供依赖对象有两种方式 （1）通过使用Inject注解标注的构造函数来创建 （2）通过工厂模式的Module来创建 如果一个依赖对象以上两种方式都能够提供，它会优先使用Module。Qualifier有一个@Named 指定相同的参数和自定义Qualifier注解一样的效果 @Qualifier @Documented @Retention(RUNTIME) public @interface Named { /** The name. */ String value() default &quot;&quot;; } Scope:作用域 管理创建的类实例的生命周期。 可以通过Scope来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。 Scope本身没有制定生命周期的能力，它的存在一是为了可读性,二是更好的管理Component和Module的关系 如果你想了解Dagger2具体调用的流程可以查看 接下来我们开始看一下要做的小项目的效果图 ok,项目比较low，废话不多说，开始我们撸代码时间 我是这样分包的 在项目中我定义了一个全局的Component类 @Singleton @Component(modules = arrayOf(DataSourceModule::class)) //注入器对象提供工厂 interface AppComponent{ /** * 全局注入器能够提供的对象 */ fun dataManager(): DataManager } 这个类为DataSourceModule用来提供DataManager对象的生成，使用DataManager来对网络请求会去查询DataSourceModule类中去找生成DataManager对象的方法 @Module class DataSourceModule { @Singleton @Provides fun provideGankService(): GankService { return Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL).build().create(GankService::class.java) } @Singleton @Local @Provides fun provideLocal(): IDataSource{ return LocalDataSource() } @Singleton @Remote @Provides fun provideRemote(service: GankService): IDataSource { return RemoteDataSource(service) } @Singleton @Provides fun provideDataManager(@Remote remote: IDataSource, @Local local: IDataSource): DataManager { return DataManager(remote,local) } } 这里推荐使用provide开头，在方法参数里面我有定义两个注解Remote和Local用来区分对应哪个一个IDataSource @Qualifier annotation class Remote provideGankService方法里面的写法使用了Gson转换用于将json转化为对象、Rxjava回调用来对网络请求的结果做不同的处理 然后我们在来看一下DataManager类 fun getWelfareList(page: Int): Flowable&lt;WelfareEntity&gt; { return remote.getWelfareList(page).onErrorResumeNext(local.getWelfareList(page)) } 主要是定义相应的规则，先在网络请求获取，当失败的时候获取本地的数据 ok,前期的工作准备完毕，为了更好去使用APPComponent，我们在Application自定一个单例 class MyApplication: Application(){ /** * 提供全局注入器的获得 */ lateinit private var appComponent: AppComponent companion object { lateinit var app: MyApplication fun getApplication(): MyApplication{ return app } } override fun onCreate() { super.onCreate() app = this appComponent = DaggerAppComponent.builder().dataSourceModule(DataSourceModule()).build() } fun getAppComponent(): AppComponent = appComponent } 开始我们的主界面，当然这个项目也就一个Activity，既然是MVP就少不了Persenter @Inject lateinit var presenter: MainPersenter 使用Inject注解来自动去创建MainPersenter对象，然后定义MainAppComponent @ActivityScope @Component(modules = arrayOf(MainActivityModule::class),dependencies = arrayOf(AppComponent::class)) interface MainAppComponent{ fun inject(activity: MainActivity) } 这里对APPComponent进行了依赖，因为在MainPersenter类里面使用到了DataManager的对象 @Module class MainActivityModule(val view: MainActivity){ @ActivityScope @Provides fun provide1Presenter(dataManager: DataManager): MainPersenter{ return MainPersenter(view,dataManager) } } 然后我们在来看一下MainPersenter class MainPersenter(val view: MainViews, val dataManager: DataManager) { //福利 fun getWelfarmList(page: Int) { dataManager.getWelfareList(page) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe { view.startLoading() } .doOnError { view.stopLoading() } .subscribe { view.stopLoading() view.showWefareList(it.results) } } 在这个类中主要是使用DataManager的对象用来获取数据并针对获取成功和失败调用View层的方法 最后我们需要初始化Dagger2注入器 //初始化Dagger2注入器 DaggerMainAppComponent.builder() .appComponent(MyApplication.getApplication().getAppComponent()) .mainActivityModule(MainActivityModule(this)) .build().inject(this) 另外在写生成ItemView的时候写了两种方式，这里也一并贴出来和大家一起分享 第一种使用with表达式 val view = with(context){ verticalLayout { gravity = Gravity.CENTER_HORIZONTAL imageView { id = R.id.welfare_item_iv imageResource = R.mipmap.ic_launcher scaleType = ImageView.ScaleType.FIT_XY lparams { height = dip(250) width = matchParent leftMargin = dip(20) rightMargin = dip(20) topMargin = dip(15) bottomMargin = dip(15) } } } } 当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果 class RecyclerUI: AnkoComponent&lt;AndroidAdapter&gt;{ override fun createView(ui: AnkoContext&lt;AndroidAdapter&gt;): View = with(ui){ verticalLayout { orientation = LinearLayout.HORIZONTAL lparams { topMargin = dip(10) leftMargin = dip(15) rightMargin = dip(15) bottomMargin = dip(10) } imageView { id = R.id.android_item_iv imageResource = R.mipmap.android_icon lparams { width = dip(90) height = dip(90) } } verticalLayout { textView { id = R.id.android_item_tv1 textSize = 18.toFloat() } textView { id = R.id.android_item_tv2 textSize = 16.toFloat() textColor = Color.RED } } } } } 至此，小项目的讲解就结束了。 ```坚持总会有结果，总会有收获的","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]},{"title":"Kotlin_anko库简单使用","slug":"Kotlin_anko的简单使用","date":"2017-12-12T11:03:25.384Z","updated":"2017-12-15T10:27:47.082Z","comments":true,"path":"2017/12/12/Kotlin_anko的简单使用/","link":"","permalink":"http://andlollipop.github.io/2017/12/12/Kotlin_anko的简单使用/","excerpt":"","text":"上一篇我们介绍了Anko库的使用，这里我们用Anko来做一个简单的RecyclerView列表 废话不说，直接撸代码 ##Start首先我们使用Anko在代码里面写一个RecyclerView，看代码 verticalLayout { recyclerView { id = R.id.main_rv //设置参数 anko为Activity扩展了act的字段 layoutManager = LinearLayoutManager(act) //layoutManager = LinearLayoutManager (this@MainActivity) padding = dip(20) adapter = this@MainActivity.adapter } } 接下来我们定义一个Adapter class MyAdapter(val ctx: Context, val items: ArrayList&lt;Resp&gt;): RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;(){ override fun onBindViewHolder(holder: MyViewHolder?, position: Int) { val resp: Resp = items.get(position) Glide.with(ctx).load(resp.owner.avatar_url).into(holder?.iv) //？.代表holder可为空 holder?.tv1?.text = resp.name holder?.tv2?.text = resp.full_name } override fun getItemCount(): Int = items.size override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): MyViewHolder { //with : 在给定对象上调用lambda中的所有方法 val view = with(ctx){ verticalLayout { orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView { id = R.id.iv lparams { rightMargin = dip(20) leftMargin = dip(15) width = dip(80) height = dip(80) } //设置默认图片 imageResource = R.mipmap.ic_launcher } verticalLayout { orientation = LinearLayout.VERTICAL textView { id = R.id.tv1 textSize = 14f textColor = 0xff0000.opaque } textView { id = R.id.tv2 textSize = 16f textColor = 0x000000 } } } } val holder = MyViewHolder(view) return holder } class MyViewHolder(itemView: View): RecyclerView.ViewHolder(itemView){ //在给定的View上查找指定的id视图 val iv: ImageView = itemView.find(R.id.iv) val tv1: TextView = itemView.find(R.id.tv1) val tv2: TextView = itemView.find(R.id.tv2) } } 是不是很炫酷，当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果，具体的代码如下： class RecycleUI : AnkoComponent&lt;MyAdapter&gt; { override fun createView(ui: AnkoContext&lt;MyAdapter&gt;): View = with(ui) { verticalLayout { orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView { id = R.id.iv lparams { rightMargin = dip(12) width = dip(80) height = dip(80) } } verticalLayout { textView { id = R.id.tv1 } textView { id = R.id.tv2 } } } } } 这里我们也是使用with来生成相应的View视图 最后便是请求数据更新Adapter的操作了 async(kotlinx.coroutines.experimental.android.UI){ //启动子线程 val data: Deferred&lt;ArrayList&lt;Resp&gt;&gt; = bg{ //读取assets里面的数据 val input = assets.open(&quot;data.json&quot;) val bytes = input.readBytes() input.close() //将得到的json串解析成对象并返回给data Gson().fromJson&lt;ArrayList&lt;Resp&gt;&gt;(String(bytes), getType&lt;ArrayList&lt;Resp&gt;&gt;()) } items.clear() items.addAll(data.await()) //这里通过调用await方法会一直等待后台的执行，当执行完毕将赋值给item集合，并更新适配器 adapter.notifyDataSetChanged()","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://andlollipop.github.io/tags/Kotlin/"}]}]}