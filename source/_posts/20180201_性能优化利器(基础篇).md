---
title: 性能优化利器(基础篇) #文章的标题
author: 老头
date: 2018-02-01 15:01 #文章生成時間
updated: 2018-02-01 15:01 #更新日期
categories:
- 性能优化
tags: 性能优化
---

### 前言
程序开发是一个混乱又疯狂的过程，内存通常都没有办法完全被释放，这些被囚禁的内存叫做内存泄漏。内存泄漏占用了大量的资源，这些资源其实可以更好的被使用，为了减少泄漏引起的混乱、负担、甚至资金损失，便有了内存管理的语言。这些语言在运行时跟踪内存分配，以便当程序不再需要时释放系统内存，完全不用工程师亲自操作，这些内存回收艺术或科学，在内存管理环节叫垃圾清理。
Android Runtime中的垃圾清理将所有影响Android Runtime的内存堆都被分割到空间中，根据这些特点，哪些数据适合放到什么空间，取决去哪个Android版本。Android工程师花费大量时间降低干扰，确保这些程序以最快的速度运行，即便是这样当有许多的GC或一大串指令一个接着一个操作，帧像时间很可能会超过16毫秒的呈像障碍，这会导致隐形的碰撞或闪躲。就是这样，如果要减少任意帧内启动GC的次数，需要着重优化程序的内存使用量,从指令的角度很难追踪这些问题的起因，但是好在Android SDk 内置了不错的一些工具帮助开发者迅速定位发生内存泄漏的代码

### java的四种引用
1、StrongReference强引用
在程序代码中普遍存在，只要某对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OOM也不会回收这种对象
2、SoftReference软引用
在java中使用SoftReference类来表示，对于软引用关联着的对象，只有内存不足的时候JVM才会回收该对象。因此这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存
软引用可以和一个引用队列ReferenceQueue联合使用，如果软引用所引用的对象呗JVM回收，这个软引用就会被加入到与之关联的引用队列中
3、WeakReference弱引用
在java中使用WeakReference类来表示，弱引用也是用来描述非必需对象，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
4、PhantomReference虚引用
虚引用和前面软引用、弱引用不同，它并不影响对象生命周期。在java中用PhantomReference类表示，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收
虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否真已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动

### 引起内存泄漏的情况
内存泄露(Memory Leak):进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.
内存溢出(OOM):当应用占用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出。比如：加载大图片。

1、静态变量引起的内存泄露
当调用getInstance时，如果传入的context是Activity的context。只要这个单例没有被释放，那么这个Activity也不会被释放，直到进程退出才会被释放

```java
public class CommUtil {
    private static CommUtil instance;
    private Context context;
    private CommUtil(Context context){
      this.context = context;
    }
    public static CommUtil getInstance(Context mcontext){
      if(instance == null){
          instance = new CommUtil(mcontext);
      }
      return instance;
    }
```

2、非静态内部类引起内存泄露(包括匿名内部类)
错误的示范
```java
public void loadData(){//隐士持有MainActivity实例
		new Thread(new Runnable() {
		    @Override
		    public void run() {
          int b=a;
          Thread.sleep(1000);
		    }
		 }).start();
}
```
解决方案：loadData方法修改为静态方法
除了上面的写法，在实际的开发中会用到Handler，我们需要自定义Handler并设置为static，但是大多数我们需要在里面使用MainActivity的引用，那该怎么办呢？这时候我们可以定义MainActivity的软引用/弱引用，然后再handleMessage里面判断如果activity为空或者finish了则不向下执行。这样就避免了handle一直持有activity引用导致的内存泄漏

3、不需要用的监听未移除会发生内存泄漏
```java
SensorManager sensorManager = getSystemService(SENSOR_SERVICE);
Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);
```
所以在onDestroy方法里面移除监听
sensorManager.unregisterListener(listener);

4、资源未关闭引起的内存泄漏情况
例如：BroadcastReceiver、Cursor、Bitmap、IO流、自定义属性等，要记得不使用的时候及时释放资源避免内存泄漏

5、无限循环动画
当使用动画的时候没有在onDestroy里面停止动画导致内存泄漏
