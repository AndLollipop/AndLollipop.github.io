---
title: 点滴面试经(算法篇) #文章的标题
author: 老头
date: 2018-01-27 15:01 #文章生成時間
updated: 2018-01-27 15:01 #更新日期
categories:
- 点滴面试经
- 算法面试
tags: 点滴面试经
---
### 前言
&emsp;&emsp;博客是记录记忆的地方，是查漏补缺的地方，更是志同道合成长的地方。现在开启面试文章的入口，欢迎大家学习并指点，由于目前本博客还没有加入评论的功能，可以先加我QQ：2414923649  

&emsp;&emsp;本篇文章用来记录算法面试的一些东西，我会不断的在里面加入新的知识，新的花样，希望大家喜欢。

### 开篇面一面

-------------------

#### 斐波那契数列
斐波那契数列是递推算法的经典例子，典型的例子是兔子产仔的问题上：如果一对两个月大的兔子以后每一个月都可以生一对小兔子，而一对新生的兔子出生两个月后才可以生小兔子。那么假定在一年内没有发生兔子的死亡事件，那么一年后共有多少对兔子呢？
解答：
使用递推来解决，最终得出F(n) = F(n-2) + F(n-1)
代码：
```java
int Fibonacci(int n){ // n为月数
  int t1,t2;
  if(n == 1 || n == 2){ // 当n为1或者2的时候都为1对兔子
    return 1;
  }else{
    t1 = Fibonacci(n-1);
    t2 = Fibonacci(n-2);
    return t1 + t2;
  }
}
```

-------------------

#### 冒泡排序
时间复杂度O($a^2$) 空间复杂度O(1) 稳定,如果还不了接冒泡排序的话可以去翻阅书籍或者去查阅资料
```java
void bubbleSort(int[] a){
  int temp;
  for(int i = 1; i < a.length; i++){
    for(int j = 0; j < a.length - i; j++){
      if(a[j] > a[j+1]){ // 相邻的数据进行比较，大的数据向后排
        //交换相邻两个数
        temp = a[j];
        a[j]=a[j+1];
        a[j+1]=temp;
      }
    }
    System.out.print("第"+i+"步排序结果：");
    for(int k = 0; k < a.length; k++){ // 遍历第i次排序的结果
      System.out.print(" "+a[k]);
    }
    System.out.print("\n");
  }
}

public static void main(String[] args) {
  new bubbleSort().bubbleSort(new int[]{118,101,105,127,112});
}
```

-------------------

#### 选择排序
选择排序算法在每一步中选取最小值来重新排列，从而达到排序的目的。时间复杂度O($a^2$) 空间复杂度O(1) 稳定
```java
void selectSort(int[] a){
  int index;
  int temp; // 交换的临时变量
  for(int i = 0; i < a.length - 1; i++){
    index = i;
    for(int j = i + 1; j < a.length; j++){
      if(a[j] < a[index]){
        index = j;
      }
    }
    //交换两个数
    if(index != i){
      temp = a[i];
      a[i] = a[index];
      a[index] = temp;
    }

    System.out.print("第"+i+"步排序结果:"); // 输出每步排序的结果
    for(int h = 0; h < a.length; h++){
      System.out.print(" "+a[h]);
    }
    System.out.print("\n");
  }
}

public static void main(String[] args) {
  new SelectSort().selectSort(new int[]{118,101,105,127,112});
}
```

-------------------

#### 插入排序
插入排序就是对未排序的数据执行逐个插入至合适的位置而完成排序，时间复杂度O($a^2$) 空间复杂度O(1) 稳定
```java
void insertionSort(int[] a) {
  int i, j, t, h;
  for (i = 1; i < a.length; i++) {
    t = a[i];
    j = i - 1;
    while (j >= 0 && t < a[j]) { // 查找i之前的元素，将a[i]添加到合适的位置
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = t;

    System.out.print("第"+i+"步排序结果:");
    for(h = 0; h < a.length; h++){
      System.out.print(" "+a[h]);
    }
    System.out.print("\n");
  }
}

public static void main(String[] args) {
  int[] sourtArr = new int[]{118,101,105,127,112};
  System.out.print("排序前:");
  for(int i = 0; i < sourtArr.length; i++){
    System.out.print(" "+sourtArr[i]);
  }
  System.out.print("\n");
  new InsertionSort().insertionSort(sourtArr);
}
```

-------------------

#### 希尔排序（缩小增量排序）
因为希尔排序比较少见，这里说一下步骤，如有不清楚请自行百度查阅资料。排序流程如下：
(1)将有n个元素的数组分成n/2个数字序列，第1个数据和第n/2+1个数据为一对，....
(2)一次循环使每一个序列对排好顺序
(3)然后再变成n/4,再次排序
(4)不断重复上述过程，随着序列减少最后变成最后一个，也就完成了整个排序
时间复杂度O(nlogn) 空间复杂度O(1) 不稳定
```java
void shellSort(int[] a) {
  int i, j, h;
  int r, temp;
  int x = 0;

  for (r = a.length / 2; r >= 1; r /= 2) {
    for (i = r; i < a.length; i++) {
      temp = a[i];
      j = i - r;
      while (j >= 0 && temp < a[j]) {
        a[j + r] = a[j];
        j -= r;
      }
      a[j + r] = temp;
    }
    x++;
    System.out.print("第"+x+"步排序结果:");
    for(h = 0; h < a.length; h++){
      System.out.print(" "+a[h]);
    }
    System.out.print("\n");
  }
}


public static void main(String[] args) {
  int[] sourtArr = new int[]{118,101,105,127,112};
  System.out.print("排序前:");
  for(int i = 0; i < sourtArr.length; i++){
    System.out.print(" "+sourtArr[i]);
  }
  System.out.print("\n");
  new ShellSort().shellSort(sourtArr);
}
```
最外层循环用来分解数组多个序列直至比较两数的间距为0为止，里面的一层循环比较数组的对应的元素，最里面的一层用来对一组数排序

-------------------

#### 快速排序
快速排序算法和冒泡排序类似，都是基于交换排序思想，快速排序对冒泡算法进行了改进，从而具有更高的执行效率
步骤：
(1) 首先设定一个分界值，通过该分界值将数组分成左右两部分
(2)将大于等于分界值的数据集集中到数组右边，小于分界值的数据集中到数组的左边，此时左边各元素都小于等于分界值，而右边各元素都大于等于分界值
(3)然后，左边和右边的数据可以独立排序和上述做同样的处理
```java
void quickSort(int[] arr, int left, int right) {
  int f, t;
  int rtemp, ltemp;
  ltemp = left;
  rtemp = right;
  f = arr[(left + right) / 2];

  while (ltemp < rtemp) {
    while (arr[ltemp] < f) {
      ++ltemp;
    }
    while (arr[rtemp] > f) {
      --rtemp;
    }
    if (ltemp <= rtemp) {
      t = arr[ltemp];
      arr[ltemp] = arr[rtemp];
      arr[rtemp] = t;
      --rtemp;
      ++ltemp;
    }
  }

  if (left < rtemp) {
    quickSort(arr, left, ltemp - 1); // 递归处理
  }
  if (ltemp < right) {
    quickSort(arr, rtemp + 1, right);
  }
}

public static void main(String[] args) {
  int[] arr = new int[]{9,7,1,20,30,22,28,19,13};
  new QuickSort().quickSort(arr, 0, arr.length-1);
  System.out.print("快排之后的顺序:");
  for(int i = 0 ; i < arr.length; i++){
    System.out.print(" "+arr[i]);
  }
  System.out.print("\n");
}
```

-------------------

#### 堆排序
堆排序算法是基于选择排序思想，其利用堆结构和二叉树的一些性质来完成数据的排序，时间复杂度O(nlogn) 空间复杂度为O(1) 不稳定














’
