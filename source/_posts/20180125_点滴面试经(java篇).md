---
title: 点滴面试经(java篇) #文章的标题
author: 老头
date: 2018-01-25 15:01 #文章生成時間
updated: 2018-01-25 15:01 #更新日期
categories:
- 点滴面试经
- java面试
tags: 点滴面试经
---
### 前言
&emsp;&emsp;博客是记录记忆的地方，是查漏补缺的地方，更是志同道合成长的地方。现在开启面试文章的入口，欢迎大家学习并指点，由于目前本博客还没有加入评论的功能，可以先加我QQ：2414923649  

&emsp;&emsp;本篇文章用来记录java面试的一些东西，我会不断的在里面加入新的知识，新的花样，希望大家喜欢。

### 开篇面一面

> 1、接口的意义

(1)重要性 <br/>
在java语言中，abstract class和interface是支持抽象类定义的两种机制 <br/>
(2)简单、规范性 <br/>
如果项目比较庞大就需要来定义一些接口，这些接口不仅仅告诉开发人员你需要实现那些业务，而且也将命名的规范也给限制住了，防止程序员错误的命名。<br/>
(3)维护、扩展性 <br/>
比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。
如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。<br/>
(4)安全、严密性 <br/>
接口是实现软件解耦合的重要手段

-------------------
> 2、抽象类的意义

本质上是相同具体概念的抽象 <br/>
1、因为抽象类不能实例化对象，必须有子类来实现才可以使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样有利于代码和程序的维护。 <br/>
2、当又有一个具有相似组件产生的时候，只需要实现该抽象类就可以获得该抽象类的那些属性和方法

-------------------
> 抽象类接口区别

1）抽象类要被子类继承，接口要被类实现<br/>
2）接口只能做方法声明，抽象类中既可以做方法声明，也可以做方法实现<br/>
3）接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br/>
4）抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。<br/>
5）抽象方法只能声明，不能实现，接口是设计的结果 ，抽象类是重构的结果<br/>
6）接口可继承接口，并可多继承接口，但类只能单根继承。

-------------------
> 3、内部类的作用

放在一个类的内部的类我们叫做内部类,作用：<br/>
1、内部类可以很好的实现隐藏，一般的非内部类，是不允许有<br/>
2、private 与protected权限的，但内部类可以<br/>
3、内部类拥有外部类的所有元素的访问权限<br/>
4、可是实现多重继承<br/>
5、可以避免修改接口去实现同一个类中两种同名方法的调用

-------------------
> 4、父类的静态方法能否被子类重写，为什么？

父类的静态方法是不能被子类重写的，重写只能适用于实例方法，不能用于静态方法，并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。

-------------------
> 5、哪些情况下的对象会被垃圾回收机制处理掉

(1)超出对象的引用作用域的时候，这个对象就会变成垃圾<br/>
(2)没有超出对象的引用作用域，给这个引用赋值为空的时候，这个引用的对象也会变成垃圾<br/>
(3)创建匿名对象时候，匿名对象用完之后会变成垃圾

-------------------
> 6、进程和线程的区别

进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同<br/>
(1)一个程序至少有一个进程，一个进程至少有一个线程<br/>
(2)线程的划分尺度小于进程，使得多线程程序的并发性高<br/>
(3)另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序的运行效率<br/>
(4)线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br/>
(5)多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别

-------------------
> 7、Java 中==和 equals 的区别， equals 和 hashCode 的区别

(1) ==操作符基本类型变量比较的是值；引用类型变量比较的是引用的地址<br/>
(2) equals方法是基类Object的方法，用于比较两个对象的内容是否相同，实际开发过程中，我们会重写equals方法，重新定义比较规则<br/>
(3) hashCode当涉及到像HashMap等与哈希表结构相关的一些类时会使用到hashCode方法，默认的hashCode实现一般是内存地址对应的数字，所以不同的对象，hashCode()的返回值是不一样的
equals(object)相同时，hashCode()的返回值也要尽量相同，当equals(object)不相同时，hashCode()也是尽量不相同以获取好的性能

-------------------
> 8、java int 与 integer 的区别

int 是基本数据类型，integer是包装数据类型（引用类型），JDK1.5之后，自动装包/拆包大大方便了基本类型数据和它们包装类地使用。

-------------------
> 9、string stringbuffer stringbuilder 区别

共同点：String StringBuffer StringBuilder 都是字符串相关函数，StringBuffer StringBuilder是AbstractStringBuilder的子类<br/>
不同点：String内容不可变，StringBuffer StringBuilder内容可变String与StringBuffer线程安全，StringBuilder非线程安全
如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer

-------------------
> 10、Java 多态

静态多态：方法重载<br/>
动态多态：方法重写<br/>
多态发生的条件：<br/>
1）要有继承<br/>
2）要有重写<br/>
3）父类引用指向子类对象<br/>
多态的好处：<br/>
1）可替换性<br/>
2）可扩充性<br/>
3）接口性<br/>
4）简化性

-------------------
> 11、容器类之间的区别

1> Vector和ArrayList  <br/>
(1)vector是线程安全的，ArrayList是线程不安全的，如果不考虑线程的安全因素使用ArrayList的效率比较高<br/>
(2)vector增长率为目前数组长度的100%，而ArrayList增长率为当前数组长度的50%，如果数据特别的大的时候使用Vector占一定的优势<br/>
(3)ArrayList 和Vector是采用数组方式存储数据，所以索引数据快插入数据慢，Vector由于使synchronized方法（线程安全）所以性能上比ArrayList要差

2> ArrayList和LinkedList <br/>
(1)ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构<br/>
(2)ArrayList适合改查，LinkedList适合增删

3> HashMap与TreeMap <br/>
(1)HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的），TreeMap实现SortedMap接口<br/>
(2)在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现

4> HashTable与HashMap<br/>
(1)HashTable是基于陈旧的Dictionary类的，HashMap是Java1.2引进的Map接口的一个实现<br/>
(2)Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br/>
(3)HashMap可以让你将空值作为一个表的条目的key或value

5> Set与List<br/>
Set中的数据对象没有顺序且不可以重复，List中的数据对象有顺序且可以重复。

-------------------
> 12、死锁的四个必要条件

(1)互斥条件，即某个资源在一段时间内只能由一个线程占有，不能同时被两个或两个以上的线程占有<br/>
(2)不可抢占条件，线程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者线程自行释放<br/>
(3)占有且申请条件，线程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外线程占有，此时该线程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。<br/>
(4)循环等待条件，存在一个线程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个线程循环等待环

-------------------
> 12、处理死锁的基本方法

(1)预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件<br/>
(2)避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁<br/>
(3)检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉<br/>
(4)解除死锁：该方法与检测死锁配合使用

-------------------
> 13、常见编码方式； utf-8 编码中的中文占几个字节；数字几个字节

一个utf8数字占1个字节，一个utf8英文字母占1个字节，少数是汉字每个占用3个字节，多数占用4个字节。

....未完待续
