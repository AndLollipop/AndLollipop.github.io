<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[揭开数据库框架神秘面纱]]></title>
    <url>%2F2018%2F04%2F21%2F20180421_%E6%8F%AD%E5%BC%80%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A1%86%E6%9E%B6%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[前言对于数据库，我们并不陌生，从Sqlite手写-&gt;数据库框架的使用， 数据库框架OrmLite优点： 1.轻量级 2.使用简单，易上手 3.封装完善 4.文档全面缺点： 1.基于反射，效率较低(本人还没有觉得效率低) 2.缺少中文翻译文档 http://ormlite.com/ LitePalLitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。还不错的框架 https://github.com/LitePalFramework/LitePal GreenDao优点: 1.存取速度快 2.支持数据库加密 3.轻量级 4.激活实体 5.支持缓存 6.代码自动生成总结：效率很高，插入和更新的速度是sqlite的2倍，加载实体的速度是ormlite的4.5倍，目前git上一直在做更新维护，start数量为9000多。 https://github.com/greenrobot/greenDAO DBFlow优点: 1.存取速度快 2.支持数据库加密 3.轻量级 4.激活实体 5.支持缓存 6.代码自动生成总结：也是很不错的数据库框架，kotlin，rx好像都支持，比GreenDao3.2的使用好像跟方便一些（还没有具体使用）。目前git上一直在做更新维护，截止2018.1.19日前start数量为3944多 https://github.com/Raizlabs/DBFlow Realm优点: 1.易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。 2.快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。 3.跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。 4.高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性 5.可视化 https://github.com/realm/realm-java 具体详情，请移步：https://blog.csdn.net/da_caoyuan/article/details/61414626 手写简易数据库框架框架原则： 调用层不需要关心数据的创建和再哪里创建 调用层不关心表的创建 调用层不关心sql语句的拼写，对象直接给你，你帮我存入数据库本文将讲解数据库的insert和query操作，因为delete update操作类似这里便不多说OK，我们来看一下Bean的写法123456789@DbTable("user")public class User &#123; @DbField("tb_name") private String name; @DbField("tb_age") private String age; ...... //get &amp; set&#125; 注解的写法12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface DbField &#123; String value();&#125; 为了更好的管理DbDao，我们需要创建一个工厂类，调用层只需要传入class便返回DbDao12345public &lt;M&gt; IDBDao&lt;M&gt; getDBDao(Class&lt;M&gt; entityClass) &#123; DBDao&lt;M&gt; dbDao = new DBDao&lt;&gt;(); dbDao.init(entityClass,sqLiteDatabase); // 初始化 return dbDao;&#125; 初始化数据12345678910111213141516/** * 初始化 * @param entityClass * @param database */public void init(Class&lt;T&gt; entityClass, SQLiteDatabase database)&#123; this.entityClass = entityClass; this.database = database; cacheMap = new HashMap&lt;&gt;(); if(entityClass.getAnnotation(DbTable.class) == null)&#123; tableName = entityClass.getClass().getSimpleName(); &#125;else&#123; tableName = entityClass.getAnnotation(DbTable.class).value(); &#125; createTable(entityClass,database);&#125; 创建表，形如123456789101112131415161718192021222324252627/** * 创建表结构 * @param entityClass * @param database */ private void createTable(Class&lt;T&gt; entityClass,SQLiteDatabase database) &#123; Field[] fields = entityClass.getDeclaredFields(); StringBuffer sb = new StringBuffer(); sb.append("create table if not exists "); sb.append(tableName); sb.append("("); for(int i = 0 ; i &lt; fields.length; i++)&#123; Field field = fields[i]; field.setAccessible(true); String fieldName = null; if(field.getAnnotation(DbField.class) != null)&#123; // 如果没有写注解则使用字段名来表示数据库的字段 fieldName = field.getAnnotation(DbField.class).value(); &#125;else&#123; fieldName = field.getName(); &#125; sb.append(fieldName + " varchar(20),"); //缓存到cacheMap中 cacheMap.put(fieldName,field); &#125; sb.replace(sb.toString().length() - 1,sb.toString().length(),")"); database.execSQL(sb.toString()); &#125; 好了，初始化操作完成了，那我们怎么来insert一个数据呢？形如下面的操作123456@Overridepublic long insert(Object entity) &#123; Map&lt;String,String&gt; map = getValues(entity); ContentValues contentValues = getContentValues(map); return database.insert(tableName,null,contentValues);&#125; 看名字就知道getValues方法将实体数据存入Map集合中，getContentValues将Map集合封装ContentValues12345678910111213141516171819202122/** * 对象拥有的成员变量 * @param entity * @return */private Map&lt;String, String&gt; getValues(Object entity) &#123; Map&lt;String,String&gt; result = new HashMap&lt;&gt;(); Iterator&lt;String&gt; iterator = cacheMap.keySet().iterator(); while (iterator.hasNext())&#123; String cacheKey = iterator.next(); Field cacheValue = cacheMap.get(cacheKey); try &#123; if(null == cacheValue.get(entity))&#123; continue; &#125; result.put(cacheKey,cacheValue.get(entity).toString()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return result;&#125; 在调用层12userDao = DBDaoFactory.factory.getDBDao(User.class);long result = userDao.insert(user); 接下来我们讲解一下查找操作1234567891011121314@Overridepublic List query(T where, String orderBy, Integer startIndex, Integer limit) &#123; Map map = getValues(where); String limitString = null; if(startIndex != null &amp;&amp; limit != null)&#123; limitString = startIndex + " , "+limit; &#125; Condition condition=new Condition(map); Cursor cursor=database.query(tableName,null,condition.getWhereClause() ,condition.getWhereArgs(),null,null,orderBy,limitString); List&lt;T&gt; result=getResult(cursor,where); cursor.close(); return result;&#125; Condition是我们用来管理whereClause和whereArgs12345678910111213141516171819202122232425262728class Condition&#123; private String whereClause; private String[] whereArgs; public Condition(Map&lt;String,String&gt; whereClause)&#123; ArrayList list = new ArrayList(); StringBuilder sb = new StringBuilder(); sb.append(" 1=1 "); // 这里省去了最后的replace操作 Set keys = whereClause.keySet(); Iterator iterator = keys.iterator(); while(iterator.hasNext())&#123; String key = (String) iterator.next(); String value = whereClause.get(key); if(value != null)&#123; sb.append(" and "+key+" =?"); list.add(value); &#125; &#125; this.whereClause=sb.toString(); this.whereArgs= (String[]) list.toArray(new String[list.size()]); &#125; public String[] getWhereArgs() &#123; return whereArgs; &#125; public String getWhereClause() &#123; return whereClause; &#125;&#125; getResult方法用来将数据库的数据设置到Bean对象中123456789101112131415161718192021222324252627282930313233343536373839private List&lt;T&gt; getResult(Cursor cursor, T where) &#123; ArrayList list=new ArrayList(); Object item; while (cursor.moveToNext()) &#123; try &#123; item=where.getClass().newInstance(); Iterator iterator=cacheMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry= (Map.Entry) iterator.next(); String colomunName= (String) entry.getKey(); Integer colmunIndex=cursor.getColumnIndex(colomunName); Field field= (Field) entry.getValue(); Class type=field.getType(); if(colmunIndex!=-1) &#123; if(type==String.class) &#123; field.set(item,cursor.getString(colmunIndex));//反射方式赋值 &#125;else if(type==Double.class) &#123; field.set(item,cursor.getDouble(colmunIndex)); &#125;else if(type==Integer.class) &#123; field.set(item,cursor.getInt(colmunIndex)); &#125;else if(type==Long.class) &#123; field.set(item,cursor.getLong(colmunIndex)); &#125;else &#123;//不支持的类型 continue; &#125; &#125; &#125; list.add(item); &#125; &#125; return list;&#125; OK，简易的数据库框架就搞完了，要想了解更多还需要深入框架去了解]]></content>
      <categories>
        <category>Android框架</category>
      </categories>
      <tags>
        <tag>Android框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android属性动画源码分析]]></title>
    <url>%2F2018%2F04%2F16%2F20180416_%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言对于属性动画我们并不陌生，从帧动画、补间动画到最后的属性动画，真可谓是一步一个坑的走过来了。自己经常在项目中应用属性动画来实现自定义View，好了，废话少说 属性动画的由来对于属性动画的到来绝非偶然，必然是为了解决帧动画、补间动画的缺点来的，那我们来说一下补间动画有什么缺点呢？ 作用对象只局限在View上，但有些情况针对视图的某个属性 没有改变View属性，只是改变了视觉的效果 动画效果单一，遇到复杂的动画显得比较吃力 属性动画的源码分析在分析源码之前我们需要先了解一下策略模式的概念 策略模式定义策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们之间可以相互替换，策略模式让算法独立于使它的客户独立而变化 角色 环境(Context)角色 - 持有一个Strategy的引用 抽象策略(Strategy)角色 - 这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略(ConcreteStrategy)角色 - 包装了相关的算法或行为。 优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。 实例假设现在要一个上商店个搞活动。 对所有的高级会员打20%的促销折扣；对中级会员打10%的促销折扣；对初级会员没有折扣。 算法一：对初级会员没有折扣。 算法二：对中级会员提供10%的促销折扣。 算法三：对高级会员提供20%的促销折扣。 抽象折扣类12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 初级会员折扣类 12345678public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的没有折扣"); return booksPrice; &#125;&#125; 中级会员折扣类1234567public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为10%"); return booksPrice * 0.9; &#125;&#125; 价格类12345678910public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; 调用者1234567public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); Price price = new Price(strategy); double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote);&#125; 策略模式在属性动画的应用1valueAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); 上面代码便使用了策略模式，其中环境(Context)角色 - ValueAnimator类抽象策略(Strategy)角色 - TimeInterpolator具体策略(ConcreteStrategy)角色 - AccelerateDecelerateInterpolator 源码分析]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera之[聚焦]]]></title>
    <url>%2F2018%2F02%2F10%2F20180210_Camera%E8%81%9A%E7%84%A6%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;上一篇文章我们介绍了人脸识别，最后在我们展示的图片时会看出人脸是识别出来了，但是那是相当模糊的，这一篇文章我们就开始讲聚焦了。 聚焦方式介绍 FOCUS_MODE_AUTO :自动对焦FOCUS_MODE_CONTINUOUS_PICTURE : 持续对焦（用于拍照模式）FOCUS_MODE_CONTINUOUS_VIDEO : 持续对焦（同于视频模式）FOCUS_MODE_EDOF :FOCUS_MODE_FIXED : 固定聚焦FOCUS_MODE_INFINITY : 无穷远聚焦FOCUS_MODE_MACRO : 微距聚焦 手机所搭载的摄像头一般都是定焦的，只是各个焦段的特性不一样，即只有一个焦平面是可以合焦的。因此在无穷远和微距模式下都是通过事先写在驱动中的一些参数去设置的。 在下面我们主要介绍持续对焦和手动对焦的实现 自动对焦持续对焦的实现很简单，分为以下简单的几步 判断相机是否支持对焦设置相机的持续对焦模式对焦前设置 cancelAutoFocus()以使持续自动对焦正常运行 1234567891011121314151617181920212223242526272829//判断是否支持聚焦public boolean isFocusAreaSupported() &#123; return (mParameters.getMaxNumFocusAreas() &gt; 0 &amp;&amp; isSupported(Camera.Parameters.FOCUS_MODE_AUTO, mParameters.getSupportedFocusModes())); &#125;private boolean isSupported(String value, List&lt;String&gt; supported) &#123; return supported == null ? false : supported.indexOf(value) &gt;= 0;&#125;// 设置聚焦public void setFocusMode()&#123; Log.d(TAG, "setFocusMode: focus num = "+mParameters.getMaxNumFocusAreas()); if (mCamera != null &amp;&amp; isFocusAreaSupported())&#123; mCamera.cancelAutoFocus(); mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); //聚焦的回调函数，可以在此做需要的界面提示设计 /*mCamera.setAutoFocusMoveCallback(new Camera.AutoFocusMoveCallback() &#123; @Override public void onAutoFocusMoving(boolean start, Camera camera) &#123; //移动对焦的回调，可以在此限制对焦界面的显示 Log.d(TAG, "onAutoFocusMoving: "); &#125; &#125;);*/ &#125; &#125; 其中在设置聚焦之前一定要执行 mCamera.cancelAutoFocus()，否则设置的移动聚焦不会生效，在开发文档中对此函数有如下解释： Cancels any auto-focus function in progress. Whether or not auto-focus is currently in progress, this function will return the focus position to the default. If the camera does not support auto-focus, this is a no-op. 手动聚焦]]></content>
      <categories>
        <category>技术周</category>
        <category>Camera开发</category>
      </categories>
      <tags>
        <tag>Camera开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera之[人脸识别]]]></title>
    <url>%2F2018%2F02%2F03%2F20180131_Camera%E4%B9%8B%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在使用相机时，我们会发现很多相机都会有人脸识别功能，开始的时候感觉很厉害，应该需要些很多代码才能实现吧，后来才知道google 已经给我们提供了人脸识别的接口，上层只要根据接口返回的人脸数据进行绘制人脸识别框就可以了。 人脸识别接口FaceDetectionListener 是google 提供的用于进行人脸识别的接口，使用也很简单： 实现接口 为camera 添加监听 开启人脸监听 123456789101112131415161718// 1. 实现接口private class MyFaceDection implements Camera.FaceDetectionListener&#123; @Override public void onFaceDetection(Camera.Face[] faces, Camera camera) &#123; //faces 获取的人脸数据 Log.d(TAG, "onFaceDetection: faces = "+faces.length); // 自定义实现的用于画人脸识别框的类 if (mFaceView != null)&#123; mFaceView.setFace(faces); &#125; &#125; &#125;// 2.设置监听 mCamera.setFaceDetectionListener(listener);// 3.开启人脸识别mCamera.startFaceDetection(); 在要停止人脸检查时 12mCamera.setFaceDetectionListener(null);mCamera.stopFaceDetection(); 经过上面简单的几步就可以实现人脸识别的监听和停止监听的功能。但是现在还不能太高兴，因为真正的坑在后面。 使用人脸识别的注意点 首先开启人脸识别一定要在startpreview 之后 执行拍照完后要重新设置人脸识别监听并开启人脸识别 在执行 autoFocus(AutoFocusCallback)(聚焦)时，人脸识别暂时失效 在一次预览调用后不能重复调用 有些设备不支持人脸识别，设置人脸识别监听之前最好检测是否支持：如果mParameters.getMaxNumDetectedFaces()&gt;0 即支持人脸识别 画人脸识别框返回的人脸数据所在的坐标系并不是我们屏幕坐标系下的数据，而是如下坐标系 左上角的坐标是(-1000,-1000),预览界面中心点是(0,0) 知道了这个点之我们就实现来实现画人脸识别框的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class FaceView extends View &#123; private static final String TAG = "FaceView"; private Camera.Face[] mFace; private Paint mPaint; private MainActivity mActivity; private int mDisplayOrientation; private int mOrientation; private boolean mMirror; private Matrix mMatrix = new Matrix(); public FaceView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mActivity = (MainActivity)context; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLUE); mPaint.setStrokeWidth(2); &#125; public void setFace(Camera.Face[] faces)&#123; if (faces != null)&#123; Log.d(TAG, "onFaceDetection: faces = "+faces.length); &#125; mFace = faces; postInvalidate(); &#125; public void clear()&#123; mFace = null; postInvalidate(); &#125; public void setDisplayOrientation(int orientation)&#123; mDisplayOrientation = orientation; &#125; public void setOrientation(int orientation)&#123; mOrientation = orientation; postInvalidate(); &#125; public void setMirror(boolean mirror)&#123; mMirror = mirror; &#125; @Override protected void onDraw(Canvas canvas) &#123; /*rw rh 获取的是预览界面的大小，mDisplayOrientation 是上一篇中我们介绍的 相机需要旋转以实现正常预览的角度，mOrientation是手机旋转的角度，mMirror 前摄是镜像，后摄非镜像*/ if (mFace != null &amp;&amp; mFace.length &gt; 0)&#123; int rw = mActivity.getPreviewWidth(); int rh = mActivity.getPreviewHeight(); if (((rh &gt; rw) &amp;&amp; ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw &gt; rh) &amp;&amp; ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) &#123; int temp = rw; rw = rh; rh = temp; &#125; Log.d(TAG, "onDraw: rw = "+rw+"; rh = "+rh+"; orientation = "+mDisplayOrientation+"; mMirror = "+mMirror); // 准备使返回的人脸坐标变换为屏幕坐标的矩阵 Util.prepareMatrix(mMatrix, mMirror, mDisplayOrientation, rw, rh); canvas.save(); mMatrix.postRotate(mOrientation); canvas.rotate(-mOrientation); RectF rect = new RectF(); for (int i = 0; i&lt;mFace.length;i++)&#123; rect.set(mFace[i].rect); mMatrix.mapRect(rect); canvas.drawRect(rect, mPaint); &#125; canvas.restore(); &#125; super.onDraw(canvas); &#125;&#125; 其中 Util.prepareMatrix(mMatrix, mMirror, mDisplayOrientation, rw, rh)的实现如下： 12345678public static void prepareMatrix(Matrix matrix,boolean isMirror,int orientation,int viewWidth, int viewHeight)&#123; matrix.setScale(isMirror?-1:1,1); matrix.postRotate(orientation); matrix.postScale(viewWidth / 2000f,viewHeight / 2000f); matrix.postTranslate(viewWidth / 2f,viewHeight / 2f); &#125; 好了，到这里我们就可以实现人脸识别功能了，展示一下效果 😂虽然很模糊，但是估计大家也能看出来是帅帅的陈伟霆啦，但是如果真的遇到了自己的男神拍出这样的照片岂不要气的在地上踩两脚，为了让手机免受迫害，就下来的一篇就来实现聚焦 让我们拍出的男神更清晰。]]></content>
      <categories>
        <category>技术周</category>
        <category>Camera开发</category>
      </categories>
      <tags>
        <tag>Camera开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决战UI绘制(上篇)]]></title>
    <url>%2F2018%2F01%2F30%2F20180128_%E5%86%B3%E6%88%98UI%E7%BB%98%E5%88%B6(%E4%B8%8A%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言UI的绘制是一个比较重要的一部分内容，通过本篇的讲解，我们将了解到Activity加载UI的视图结构以及View的绘制流程。本篇文章通过对问题进行探索，分析相应源码得到解答。 Activity中View的加载过程随着每天敲着重复代码工作，我们慢慢的产生了一些疑问，这里列举自己的一些疑问1、只知道setContentView能显示视图，但不知道为什么调用了之后就可以显示2、PhoneWindow是什么？Window和它是什么关系?3、DecorView是做什么的？和我们的布局又有什么样的关系？4、requestFeature为什么要在setContentView之前调用OK，针对以上问题我们开始了学习源码的兴趣，进入setContentView1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; getWindow()是window对象，那它的实现类是什么呢？我们可以在attach方法里面看到mWindow = new PhoneWindow(this, window, activityConfigCallback); 这样就清晰了，PhoneWindow是Window的子类，通过看官网解释知道PhoneWindow是window的唯一子类 进入PhoneWindow123456789101112131415161718192021@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); // 1 &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); // 2 &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; //3 final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); // 4 &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; // 5 cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 1、生成DecorView对象2、当不是第一次进入的时候执行mContentParent.removeAllViews方法，这样我们在Activity多次setContentView的时候将重新加载布局3、判断是否有转场动画，如果有的话则使用TranstionManager来进行切换，在讲解ContraintSet的时候有讲解到4、将layoutResId布局添加到mContentParent视图中5、当初始化完毕之后调用Activity的onContentChanged方法(在我们查看Activity的attach方法的时候有这样一行代码mWindow.setCallback(this))，我们可以在onContentChanged方法里面做一些initView操作了OK，当首次进入的时候执行installDecor方法1234567891011121314private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); ...... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); .......&#125; 通过查看generateDecor方法可知DecorView是FrameLayout的子类12345678910111213141516171819protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); ......//设置Flag和Feature WindowManager.LayoutParams params = getAttributes(); ......//设置背景颜色 // 填充DecorView int layoutResource; ......//设置DecorView的布局文件 mDecor.startChanging(); mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; ...... mDecor.finishChanging(); return contentParent;&#125; 从上面的分析知道contentParent是android.R.id.content的控件，OK，我们以screen_simple为例12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;ViewStub android:id="@+id/action_mode_bar_stub" android:inflatedId="@+id/action_mode_bar" android:layout="@layout/action_mode_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="?attr/actionBarTheme" /&gt; &lt;FrameLayout android:id="@android:id/content" android:layout_width="match_parent" android:layout_height="match_parent" android:foregroundInsidePadding="false" android:foregroundGravity="fill_horizontal|top" android:foreground="?android:attr/windowContentOverlay" /&gt;&lt;/LinearLayout&gt; 我们看到contentParent是FrameLayout布局，外层是线性布局，这样我们的整个View的层级结构弄清楚了，外层是继承FrameLayout的DecorView，里面包裹LinearLayout，在里面有ActionBar、继承FrameLayout布局的contentParent，来个图熟悉一下：ok,大致的层级结构我们也都熟悉了，那我们的写的布局是如何添加到contentParent里面的呢？针对这个问题我们需要分析一下mLayoutInflater.inflate(layoutResID, mContentParent)方法内部做了什么操作1234567891011121314151617181920212223242526272829303132333435363738394041public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; View result = root; try &#123; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // 循环遍历找到根标签 // Empty &#125; ....... if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; // 当root为merge的时候，判断root==null或者attachToRoot=false则抛异常 throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; //根据获取的Tag创建相应的View final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // 得到root生成Layoutparams params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // 1 temp.setLayoutParams(params); &#125; &#125; // 填充所有的子View添加到temp中 rInflateChildren(parser, temp, attrs, true); // 2 if (root != null &amp;&amp; attachToRoot) &#123; // 3 root.addView(temp, params); &#125; // 决定是否返回root还是temp if (root == null || !attachToRoot) &#123; // 4 result = temp; &#125; &#125; &#125; return result; &#125; &#125; 我们来对1/3/4进行分析下，因为这几个都涉及到了root和attachToRoot1、attachToRoot = false的情况下，1将执行temp的LayoutParams=root的LayoutParams 3将不执行 4将执行 ，所以可以得出这样的结论：当attachToRoot返回false的时候，inflate得到的是布局生成的view里面的布局参数和传入的root参数一样，并且内部并没有添加到root上，需要手动addView2、attachToRoot = true的情况下，1将不执行 3将执行 4将不执行，所以可以得出这样的结论：当attachToRoot返回true的时候，inflate得到的是root并且内部将自动将布局生成的view添加到root中ok,还有2没有进行分析，来看2的源码12345678910111213141516171819202122232425262728293031void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123;// 这里判断include是否根View，如果是根View则报错 throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; // 如果发现是merge的话则报错 因为merge必须是根元素 throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; // 递归调用rInflateChildren并将子view添加到viewGroup中 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; // 当finishInflate为true的话则调用Parent的onFinishInflate方法 parent.onFinishInflate(); &#125;&#125; ok,LayoutInflater的填充视图就完了，最后来个图熟悉一下流程： AppCompatActivity中View的加载过程未完，待续…]]></content>
      <categories>
        <category>技术周</category>
        <category>玩转UI</category>
      </categories>
      <tags>
        <tag>玩转UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写IOC架构]]></title>
    <url>%2F2018%2F01%2F28%2F20180126_%E6%89%8B%E5%86%99IOC%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这篇我们来讲解一下IOC架构，IOC名为控制反转（Inversion of Control，英文缩写为IoC），IOC的原则就是无需自己来new对象，等待加载这个类的时候，IOC帮你注入（new）进去，好啦！网上已经有好多的文章了，那还为啥还要写呢，感觉别人写的是别人的，自己写了之后才是自己的，所以自己坚持也要写一下，下面有一些写的不错的文章供大家观摩。 Android 进阶 教你打造 Android 中的 IOC 框架 【ViewInject】 （上）http://blog.csdn.net/lmj623565791/article/details/39269193Android 进阶 教你打造 Android 中的 IOC 框架 【ViewInject】 （上）http://blog.csdn.net/lmj623565791/article/details/39269193 代理模式原本代理模式应该放到设计模式板块，但是在本文中使用到了，这里也介绍一下吧，代理模式分为动态代理和静态代理，当然在Javaweb中也有CGLib动态代理，这里我们来详细介绍一下它们的区别和演进过程，let’s go在开始之前我们先来从无代理开始讲起无代理先来看一下代码，很简单123public interface Humen&#123; void eat(String food);&#125; 12345public class HumenImpl extends Humen&#123; void eat(String food)&#123; System.out.println("eat"); &#125;&#125; 上面的代码可以理解为一个人吃饭，如果我们要在吃饭前和吃饭后需要做一些事该怎么做呢？或者修改HumenImpl内部的代码或者重写一个eat方法等等，这些都设定了死的业务逻辑，在代码复用和业务拓展的角度看这是非常不好的做法静态代理对上面的代码进行改造123456789101112131415161718public class HumenProxy implements Humen &#123; private Humen humen; public HumenProxy(Humen humen)&#123; this.humen = humen; &#125; @Override public void eat(String food) &#123; before(); humen.eat(food); after(); &#125; private void before() &#123; &#125; private void after() &#123; &#125;&#125; 静态代理为我们带来了一定的灵活性，在不修改被代理类的基础上，实现修改少量的代码来获得额外的功能。那静态代理是否真正就能满足所有的需求呢？答案是no,我们来举个例子，如果我们还有其他的逻辑并且before和after是一样的，那该怎么办呢？我们可能让这个代理类来实现别的接口的方法，但这些方法的调用逻辑基本上相似，我们就需要写很多的代码来完成相应的需求，这样就衍生出了动态代理 动态代理12345678910111213public class DynamicProxy implements InvocationHandler &#123; private Object target; public DynamicProxy(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125;&#125; 调用12345678910public static void main(String[] args) &#123; Humen humen = new HumenImpl(); DynamicProxy dynamicProxy = new DynamicProxy(humen); Humen humenProxy = (Humen) Proxy.newProxyInstance( humen.getClass().getClassLoader(), humen.getClass().getInterfaces(), dynamicProxy); humenProxy.eat("rice");&#125; 静态代理和动态代理都讲完了，总结一下 然而，Proxy已经设计的非常的完美了，但是还是有一点点小小的遗憾之处，那就是它无法仅支持interface的桎梏。不完美并不等于不伟大，伟大是一种本质，Java 动态代理就是一个例子。 CGLib动态代理链接地址：https://sourceforge.net/projects/cglib/files/CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理。CGLib是一个类库 被代理类12345public class BookFace &#123; public void add()&#123; System.out.println("add BookFace"); &#125;&#125; GCLib代理类123456789101112131415161718192021222324public class CGLibProxy implements MethodInterceptor&#123; private Object target; public Object getInstance(Object target)&#123; this.target = target; // 给业务对象赋值 Enhancer enhancer = new Enhancer(); // 创建加速器，用来创建动态代理 enhancer.setSuperclass(this.target.getClass()); // 为加速器指定要代理的业务类 enhancer.setCallback(this);// 对于代理类上的所有方法的调用都会调用CallBack，而CallBack则需要实现intercept方法进行拦截 return enhancer.create(); // 创建动态代理类对象并返回 &#125; @Override public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy) throws Throwable &#123; before(); Object result = proxy.invokeSuper(arg0, arg2);// 注意这里调用的是invokeSuper方法 after(); return result; &#125; private void before() &#123; System.out.println("before"); &#125; private void after() &#123; System.out.println("after"); &#125;&#125; 调用123456public static void main(String[] args) &#123; BookFace bookface = new BookFace(); CGLibProxy cgLibProxy = new CGLibProxy(); BookFace bookFaceProxy = (BookFace) cgLibProxy.getInstance(bookface); bookFaceProxy.add();&#125; 在使用CGLib动态代理的优势是很明显了，对它我们就可以我没有接口的类包装前置和后置方法了，虽然CGLib不需要接口信息，但是它拦截并包装被代理类的所有方法。综上，各有优势，灵活掌握 手写IOC架构XUtils的使用：https://github.com/wyouflf/xUtils3当然在本文中并非将XUtils中的所有内容都讲解一遍，这里主要针对三个模块：setContentView、findViewById初始化View、事件 setContentView初始化布局比较简单，就是简单的反射规则123456789101112131415public static void injectLayout(Context context) &#123; int layoutId = 0; Class&lt;?&gt; clazz = context.getClass(); //拿到MainActivity类上面的注解 ContentView contentView = clazz.getAnnotation(ContentView.class); if (contentView != null) &#123; layoutId = contentView.value(); try &#123; Method method = clazz.getMethod("setContentView", int.class); method.invoke(context, layoutId); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; findViewById初始化View12345678910111213141516171819202122232425262728public static void injectView(Context context) &#123; Class&lt;?&gt; aClass = context.getClass(); //获取到MainActivity里面所有的成员变量 包含 textView Field[] fields = aClass.getDeclaredFields(); for (Field field : fields) &#123; //得到成员变量的注解 ViewInject viewInject = field.getAnnotation(ViewInject.class); if (viewInject != null) &#123; //拿到id R.id.text int valueId = viewInject.value(); try &#123; //View view=activity.findViewById() Method method = aClass.getMethod("findViewById", int.class); //反射调用方法 View view = (View) method.invoke(context, valueId); field.setAccessible(true); field.set(context, view); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 事件处理事件处理就有必要了解一下事件三要素：事件源、事件、事件回调，如下图： 为了存储事件的三要素，这里使用了注解中的注解1234567891011121314151617181920212223242526272829@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface EventBase &#123; /** * 设置监听的方法 * @return */ String listenerSetter(); /** * 事件类型 * @return */ Class&lt;?&gt; listenerType(); /** * 回调方法 * 事件被触发后，执行回调方法名称 */ String callBackMethod();&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@EventBase(listenerSetter = "setOnClickListener", listenerType = View.OnClickListener.class, callBackMethod = "onClick")public @interface OnClick&#123; int[] value();&#125; 当在方法上写了@OnClick({R.id.a,R.id.b})这种，该怎么取出相应的ID和知道该ID的控件要设置哪个点击事件，这时候就需要对Method进行遍历了取出事件三要素1234567891011121314151617181920212223//获取Activity里面 所有方法Method[] methods = clazz.getDeclaredMethods();//遍历Activity所有方法for (Method method : methods) &#123;//获取方法上所有的注解Annotation[] annotations = method.getAnnotations();for (Annotation annotation : annotations) &#123; //获取注解 anntionType OnClick OnLongClck Class&lt;?&gt; anntionType = annotation.annotationType(); //获取注解的注解 onClick 注解上面的EventBase EventBase eventBase = anntionType.getAnnotation(EventBase.class); if (eventBase == null) &#123; continue; &#125; /* 开始获取事件三要素 通过反射注入进去 1 listenerSetter 返回 setOnClickListener字符串 */ String listenerSetter = eventBase.listenerSetter(); //得到 listenerType--》 View.OnClickListener.class, Class&lt;?&gt; listenerType = eventBase.listenerType(); //callMethod---&gt;onClick String callMethod = eventBase.callBackMethod(); 取出onClick的IDs12Method valueMethod = anntionType.getDeclaredMethod("value");int[] viewIds = (int[]) valueMethod.invoke(annotation); 使用动态代理Invocation 1234567891011 /* listenerSetter setOnClickLitener listenerType View.OnClickListener.class */Method setOnClickListener = view.getClass().getMethod(listenerSetter, listenerType);ListenerInvocationHandler handler = new ListenerInvocationHandler(context, methodMap);//proxyy已经实现了listenerType接口Object proxy = Proxy.newProxyInstance (listenerType.getClassLoader(), new Class[]&#123;listenerType&#125;, handler);setOnClickListener.invoke(view, proxy); ok,这样你就可以在代码里面使用注解来代替setOnClickListener了 12345@OnClick(R.id.text2)public void onClick()&#123; Toast.makeText(this,"单击",Toast.LENGTH_SHORT).show();&#125; 这里相应的效果就不贴了，非常简单。经过一段学习之后感觉IOC的架构也不过如此嘛！Fighting]]></content>
      <categories>
        <category>技术周</category>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点滴面试经(算法篇)]]></title>
    <url>%2F2018%2F01%2F27%2F20180127_%E7%82%B9%E6%BB%B4%E9%9D%A2%E8%AF%95%E7%BB%8F(%E7%AE%97%E6%B3%95%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客是记录记忆的地方，是查漏补缺的地方，更是志同道合成长的地方。现在开启面试文章的入口，欢迎大家学习并指点，由于目前本博客还没有加入评论的功能，可以先加我QQ：2414923649 &emsp;&emsp;本篇文章用来记录算法面试的一些东西，我会不断的在里面加入新的知识，新的花样，希望大家喜欢。 开篇面一面 排序算法由于网上已经有比较好的文章了，这里列出相应的地址，接下来就是不断的去研究，不断的去学习就哦了，好了不多说了https://www.jianshu.com/p/ae97c3ceea8d 斐波那契数列斐波那契数列是递推算法的经典例子，典型的例子是兔子产仔的问题上：如果一对两个月大的兔子以后每一个月都可以生一对小兔子，而一对新生的兔子出生两个月后才可以生小兔子。那么假定在一年内没有发生兔子的死亡事件，那么一年后共有多少对兔子呢？解答：使用递推来解决，最终得出F(n) = F(n-2) + F(n-1)代码：12345678910int Fibonacci(int n)&#123; // n为月数 int t1,t2; if(n == 1 || n == 2)&#123; // 当n为1或者2的时候都为1对兔子 return 1; &#125;else&#123; t1 = Fibonacci(n-1); t2 = Fibonacci(n-2); return t1 + t2; &#125;&#125; #### ’]]></content>
      <categories>
        <category>点滴面试经</category>
        <category>算法面试</category>
      </categories>
      <tags>
        <tag>点滴面试经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点滴面试经(java篇)]]></title>
    <url>%2F2018%2F01%2F25%2F20180125_%E7%82%B9%E6%BB%B4%E9%9D%A2%E8%AF%95%E7%BB%8F(java%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客是记录记忆的地方，是查漏补缺的地方，更是志同道合成长的地方。现在开启面试文章的入口，欢迎大家学习并指点，由于目前本博客还没有加入评论的功能，可以先加我QQ：2414923649 &emsp;&emsp;本篇文章用来记录java面试的一些东西，我会不断的在里面加入新的知识，新的花样，希望大家喜欢。 开篇面一面接口的意义(1)重要性在java语言中，abstract class和interface是支持抽象类定义的两种机制(2)简单、规范性如果项目比较庞大就需要来定义一些接口，这些接口不仅仅告诉开发人员你需要实现那些业务，而且也将命名的规范也给限制住了，防止程序员错误的命名。(3)维护、扩展性比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。(4)安全、严密性接口是实现软件解耦合的重要手段 抽象类的意义本质上是相同具体概念的抽象1、因为抽象类不能实例化对象，必须有子类来实现才可以使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样有利于代码和程序的维护。2、当又有一个具有相似组件产生的时候，只需要实现该抽象类就可以获得该抽象类的那些属性和方法 抽象类接口区别1）抽象类要被子类继承，接口要被类实现2）接口只能做方法声明，抽象类中既可以做方法声明，也可以做方法实现3）接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。4）抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。5）抽象方法只能声明，不能实现，接口是设计的结果 ，抽象类是重构的结果6）接口可继承接口，并可多继承接口，但类只能单根继承。 内部类的作用放在一个类的内部的类我们叫做内部类,作用：1、内部类可以很好的实现隐藏，一般的非内部类，是不允许有2、private 与protected权限的，但内部类可以3、内部类拥有外部类的所有元素的访问权限4、可是实现多重继承5、可以避免修改接口去实现同一个类中两种同名方法的调用 父类的静态方法能否被子类重写，为什么？父类的静态方法是不能被子类重写的，重写只能适用于实例方法，不能用于静态方法，并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。 哪些情况下的对象会被垃圾回收机制处理掉(1)超出对象的引用作用域的时候，这个对象就会变成垃圾(2)没有超出对象的引用作用域，给这个引用赋值为空的时候，这个引用的对象也会变成垃圾(3)创建匿名对象时候，匿名对象用完之后会变成垃圾 进程和线程的区别进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同(1)一个程序至少有一个进程，一个进程至少有一个线程(2)线程的划分尺度小于进程，使得多线程程序的并发性高(3)另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序的运行效率(4)线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制(5)多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别 Java 中==和 equals 的区别， equals 和 hashCode 的区别(1) ==操作符基本类型变量比较的是值；引用类型变量比较的是引用的地址(2) equals方法是基类Object的方法，用于比较两个对象的内容是否相同，实际开发过程中，我们会重写equals方法，重新定义比较规则(3) hashCode当涉及到像HashMap等与哈希表结构相关的一些类时会使用到hashCode方法，默认的hashCode实现一般是内存地址对应的数字，所以不同的对象，hashCode()的返回值是不一样的equals(object)相同时，hashCode()的返回值也要尽量相同，当equals(object)不相同时，hashCode()也是尽量不相同以获取好的性能 java int 与 integer 的区别int 是基本数据类型，integer是包装数据类型（引用类型），JDK1.5之后，自动装包/拆包大大方便了基本类型数据和它们包装类地使用。 string stringbuffer stringbuilder 区别共同点：String StringBuffer StringBuilder 都是字符串相关函数，StringBuffer StringBuilder是AbstractStringBuilder的子类不同点：String内容不可变，StringBuffer StringBuilder内容可变String与StringBuffer线程安全，StringBuilder非线程安全如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer Java 多态静态多态：方法重载动态多态：方法重写多态发生的条件：1）要有继承2）要有重写3）父类引用指向子类对象多态的好处：1）可替换性2）可扩充性3）接口性4）简化性 容器类之间的区别1&gt; Vector和ArrayList(1)vector是线程安全的，ArrayList是线程不安全的，如果不考虑线程的安全因素使用ArrayList的效率比较高(2)vector增长率为目前数组长度的100%，而ArrayList增长率为当前数组长度的50%，如果数据特别的大的时候使用Vector占一定的优势(3)ArrayList 和Vector是采用数组方式存储数据，所以索引数据快插入数据慢，Vector由于使synchronized方法（线程安全）所以性能上比ArrayList要差2&gt; ArrayList和LinkedList(1)ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构(2)ArrayList适合改查，LinkedList适合增删3&gt; HashMap与TreeMap(1)HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的），TreeMap实现SortedMap接口(2)在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现4&gt; HashTable与HashMap(1)HashTable是基于陈旧的Dictionary类的，HashMap是Java1.2引进的Map接口的一个实现(2)Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的(3)HashMap可以让你将空值作为一个表的条目的key或value5&gt; Set与ListSet中的数据对象没有顺序且不可以重复，List中的数据对象有顺序且可以重复。 死锁的四个必要条件(1)互斥条件，即某个资源在一段时间内只能由一个线程占有，不能同时被两个或两个以上的线程占有(2)不可抢占条件，线程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者线程自行释放(3)占有且申请条件，线程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外线程占有，此时该线程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。(4)循环等待条件，存在一个线程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个线程循环等待环 处理死锁的基本方法(1)预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件(2)避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁(3)检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉(4)解除死锁：该方法与检测死锁配合使用 常见编码方式； utf-8 编码中的中文占几个字节；数字几个字节一个utf8数字占1个字节，一个utf8英文字母占1个字节，少数是汉字每个占用3个字节，多数占用4个字节。 Http和Https的不同之处1、Http的URL以http://开头，而https的URL以https://开头2、Http是不安全的，而Https是安全的3、Http标准端口是80，而Https的标准端口是4434、在OSI网络模型中，Http工作于应用层，而Https工作在传输层5、Http无需加密，而Https需要认证证书 Socket服务端/客户端通信步骤1、创建ServerSocket和Socket2、打开连接到Socket的输入/输出流3、按照协议对socket进行读/写操作4、关闭输入输出流、关闭Socket java的IO接口1、基于字节操作的IO接口 inputStream outputStream2、基于字符操作的IO接口 BufferedReader BufferWriter3、基于磁盘操作的IO接口 File4、基于网络操作的IO接口 Socket 阻塞式IO发生条件1、BIO数据在写入outputStream或者inputStream读取时可能会阻塞2、当前一些需要大量Http长连接的情况3、需要另外一种新的IO操作方式 Char型变量中能不能存储一个中文汉字？为什么？char型变量是用来存储Unicode编码字符的，Unicode编码字符集中包含了汉字，所以char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在Unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊的汉字。Unicode编码占用两个字节，所以char型变量也是占用两个字节 ….未完待续]]></content>
      <categories>
        <category>点滴面试经</category>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>点滴面试经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点滴面试经(Android篇)]]></title>
    <url>%2F2018%2F01%2F24%2F20180124_%E7%82%B9%E6%BB%B4%E9%9D%A2%E8%AF%95%E7%BB%8F(Android%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客是记录记忆的地方，是查漏补缺的地方，更是志同道合成长的地方。现在开启面试文章的入口，欢迎大家学习并指点，由于目前本博客还没有加入评论的功能，可以先加我QQ：2414923649 &emsp;&emsp;本篇文章用来记录Android面试的一些东西，我会不断的在里面加入新的知识，新的花样，希望大家喜欢。 开篇面一面1、数据库的操作类型有哪些，如何导入外部数据库？1&gt; 使用数据库的方式有哪些？（1）openOrCreateDatabase(String path);（2）继承SqliteOpenHelper类对数据库及其版本进行管理(onCreate,onUpgrade)当在程序当中调用这个类的方法getWritableDatabase()或者getReadableDatabase();的时候才会打开数据库。如果当时没有数据库文件的时候，系统就会自动生成一个数据库。2&gt; 操作的类型：增删改查CRUD直接操作SQL语句：SQliteDatabase.execSQL(sql);面向对象的操作方式：SQLiteDatabase.insert(table, nullColumnHack, ContentValues);3&gt;如何导入外部数据库？一般外部数据库文件可能放在SD卡或者res/raw或者assets目录下面。写一个DBManager的类来管理，数据库文件搬家，先把数据库文件复制到/data/data/包名/databases/目录下面，然后通过db.openOrCreateDatabase(db文件),打开数据库使用。比如：多线程操作数据库的时候，我采取的是封装使用互斥锁来解决…… 2、是否使用过本地广播，和全局广播有什么差别？引入本地广播的机制是为了解决安全性的问题(1)发送本地广播不会脱离应用程序，比用担心app的数据泄露；(2)其他的程序无法发送到我的应用程序内部，不担心安全漏洞。（比如：如何做一个杀不死的服务—监听火的app 比如微信、友盟、极光的广播，来启动自己。）(3)发送本地广播比发送全局的广播高效。（全局广播要维护的广播集合表 效率更低。全局广播，意味着可以跨进程，就需要底层的支持。）本地广播不能用静态注册。—-静态注册：可以做到程序停止后还能监听。注册LocalBroadcastManager.getInstance(this).registerReceiver(new XXXBroadCastReceiver(), new IntentFilter(action));取消注册LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver) 是否使用过 IntentService，作用是什么， AIDL 解决了什么问题？1&gt; IntentService作用如果有一个任务，可以分成很多个子任务，需要按照顺序来完成，如果需要放到一个服务中完成，那么使用IntentService是最好的选择。一般我们所使用的Service是运行在主线程当中的，所以在service里面编写耗时的操作代码，则会卡主线程会ANR。为了解决这样的问题，谷歌引入了IntentService.IntentService的优点：（1）它创建一个独立的工作线程来处理所有一个一个intent。（2）创建了一个工作队列，来逐个发送intent给onHandleIntent()（3）不需要主动调用stopSelf()来结束服务，因为源码里面自己实现了自动关闭。（4）默认实现了onBind()返回的null。（5）默认实现的onStartCommand()的目的是将intent插入到工作队列。2&gt; AIDL 解决了什么问题？AIDL的全称：Android Interface Definition Language，安卓接口定义语言。由于Android系统中的进程之间不能共享内存，所以需要提供一些机制在不同的进程之间进行数据通信。远程过程调用：RPC—Remote Procedure Call，安卓就是提供了一种IDL的解决方案来公开自己的服务接口。AIDL:可以理解为双方的一个协议合同。双方都要持有这份协议—文本协议 xxx.aidl文件（安卓内部编译的时候会将aidl协议翻译生成一个xxx.java文件—代理模式：Binder驱动有关的，Linux底层通讯有关的。）在系统源码里面有大量用到aidl，比如系统服务、电视机顶盒系统开发、你的服务要暴露给别的开发者来使用。 Looper、Handler、Message三者关系 具体的详情可以看鸿洋大神的博客：http://blog.csdn.net/lmj623565791/article/details/38377229 进程间通信的几种方式进程间通信大概有四种方式：1、应用之间的跳转Intent方式2、应用之间共享数据库方式ContentProvider3、广播方式，如应用接受系统的广播4、AIDL服务方式/Messager信使 三级缓存(1)内存缓存LruCache (2)本地缓存DiskLruCache (3)网络具体的详情可以看郭霖大神的讲解内存：http://blog.csdn.net/guolin_blog/article/details/9526203本地：http://blog.csdn.net/guolin_blog/article/details/28863651这里需要注意一点的是：内存缓存和本地缓存都涉及到存储的问题，内存缓存可以将网络地址转化为hashcode值作为LruCache的key,本地缓存DiskLruCache可以将存储的目录地址用hashcode来存储 什么是ActivityActivity是Android程序与用户交互的窗口，具有 生命周期以及一些跳转逻辑 Activity生命状态有四种状态：1、running Activity在前台 交互状态2、paused3、stopped4、killed：已经被回收掉 Activity生命周期分析Activity启动-&gt;onCreate-&gt;onStart-&gt;onResume点击Home键回到主界面(Activity不可见)-&gt;onPause-&gt;onStop当我们再次回到原Activity时-&gt;onRestart-&gt;onStart-&gt;onResume退出当前Activity-&gt;onPause-&gt;onStop-&gt;onDestroy android进程优先级1、前台进程：与用户交互、优先级最高2、可见进程：如果一个进程不含有任何前台的组件，但仍可被用户在屏幕上可见3、服务进程：startService4、后台进程：不可见5、空进程：不包含任何活跃的组件则认为空进程 scheme跳转协议android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉app跳转那个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面等 FragmentPagerAdapter与FragmentStatePageAdapter的区别FragmentPagerAdapter中的destroyItem中调用了Fragment的detach方法，并没有释放内存，适用于页面较少情况FragmentStatePageAdapter中的destroyItem中调用了remove方法是真正的释放了，内存适用于页面较多情况 Fragment通信1、在Fragment中调用Activity中的方法 getActivity2、在Activity中调用Fragment中的方法 接口回调3、在Fragment中调用Fragment中的方法 findFragmentById Thread和Service的区别Thread:Thread是程序执行的最小单元，它是分配CPU的基本单位。可以用Thread来执行一些一步的操作Service:Service是Android的一种机制，当它运行的时候如果是Local Service，那么对应的Service是运行在主进程的main线程上的；如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！ 广播种类1、普通广播 sendBroadcast2、有序广播 sendOrderedBroadcast3、本地广播 LocalBroadcastManager 广播的内部实现机制1、自定义广播接受者BroadcastReceiver，并复写onRecvice2、通过Binder机制向AMS（ActivityManagerService）进行注册3、广播发送者通过Binder机制向AMS发送广播4、AMS查找符合相应条件(IntentFilter等)的BroadcastReceiver，将广播发送到BroadcastReceiver相应的消息循环队列5、消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive方法 LocalBroadcastManager详解1、使用它发送的广播将只在自身APP内传播，因此你不必担心泄露隐私数据2、其它APP无法对你的APP发送该广播，因为你的APP根本就不可能接受到非自身应用发送的该广播，因此你不必担心有安全漏洞可以利用3、比系统的全局广播更加高效 LocalBroadcastManager内部详解1、LocalBroadcastManager高效的原因主要是因为它内部是通过Handler实现的，它的sendBroadcast方法含义并非和我们平时所用的一样，它的sendBroadcast方法其实是通过handler发送一个Message实现的2、既然是它内部是通过Handler来实现广播发送的，那么相比与系统广播通过Binder实现那肯定是更高效了，同时使用Handler来实现，别的应用无法向我们的应用发送该广播，而我们应用内发送的广播也不会离开我们的应用3、LocalBroadcastManager内部协作主要是靠这两个Map集合：mReceivers和mActions,当然还有一个List集合mPendingBroadcasts，这个主要就是存储待接收的广播对象。 WebView常见的一些坑1、在Android API16及以前版本存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用WebView.addJavaScriptInterface方法，远程攻击者可通过使用java Reflection API利用该漏洞执行任意java对象的方法2、WebView在布局文件中的使用需要在onDestroy里面先removeAllViews之后再调用Webview.destroy()3、jsbridge native端和web的桥4、后台耗电6、WebView硬件加速导致页面渲染的问题 WebView内存泄漏1、创建独立进程，简单暴力，不过可能涉及进程间通信（常用的方法：减少了主进程的内存容量）2、动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉 什么是Binder1、通常意义下，Binder指的是一种通信机制2、对于Server进程来说，Binder指的是Binder本地对象/对于Client来说，Binder指的是Binder代理对象3、对于传输过程而言，Binder是可以进行跨进程传递的对象 为什么要使用Binder1、Android使用的Linux内核拥有着非常多的跨进程通信机制2、性能上3、安全上 双方校验 OkHttp使用1、创建一个OkhttpClient对象2、创建一个request对象，通过内部类Builder调用生成Request对象3、创建一个Call对象，调用execute/enqueue OkHttp的源码解析 Retrofit源码解析1、在retrofit中通过一个接口作为http请求的api接口2、创建一个retrofit的实例3、调用API接口 Retrofit 动态代理解析1、首先，通过method把它转化成ServiceMethod2、然后，通过serviceMethod，args获取到OKhttpCall对象3、最后，再把OKhttpCall进一步封装并返回Call对象 Retrofit源码解析1、创建一个Retrofit对象2、通过Retrofit.create方法是怎么把我们所定义的接口转化成接口实例并使用接口中的方法3、最终的网络请求调用的okhttp …未完，待续]]></content>
      <categories>
        <category>点滴面试经</category>
        <category>Android面试</category>
      </categories>
      <tags>
        <tag>点滴面试经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera之[方向与尺寸]]]></title>
    <url>%2F2018%2F01%2F23%2F20180120_Camera%E6%96%B9%E5%90%91%E5%92%8C%E5%B0%BA%E5%AF%B8%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp; 上一次分析了Camera的基本使用，并且使用实现了基本的预览功能，在上一次我们提到了使用setDisplayOrientation() 设置相机的预览方向，还有看上一节分享的预览图可以发现图像被拉伸了。那我们这一节不要讲解下如何控制方向和尺寸的问题。 Camera 中的方向&emsp;&emsp;在相机开发中有三个方向的定义：屏幕方向、图像传感器方向、拍照后的照片方向。在开发时，我们要确保这三个方向保持一致，这样我们才能预览以及拍出我们想看到的照片。 屏幕方向 图像传感器方向&emsp;&emsp;屏幕方向我们应该都不陌生，就是以屏幕左上角为原点，横向为X轴正方向，纵向为Y轴正方向。而相机的图像传感器方向是由安装的Image Sensor决定的，在多数的手机中后置相机的图像传感器的方向是以屏幕右上角为原点，纵向为X的正方向，横向为Y轴的正方向。 对于横屏应用来说，屏幕的方向和绘制摄像头图像传感器方向一致，所以看到的图像是正方向的 而当屏幕竖直方向时，屏幕方向和图像传感器方向不一致，这是我们看到的图像就是这样的 不知道大家刚刚开始看到图像时是否会感觉很奇怪，结合上面的坐标系，这个小人的脑袋不是应该朝向右面吗,如果是这样呢，那我就很高兴找到一个同盟，哈哈。但是后来经过事实验证小人的脑袋确实是朝向左面的，于是经过各种理解终于找到了一种说服自己的方法，这种方法可能不权威，但是还是想说一下：首先从上面的图中我们可以看到屏幕的和图像传感器有90度的夹角，当图像传感器采集到图像后会以某种方式映射到屏幕上的，这种方式就是逆时针旋转90度，因为只有这样两个坐标系才是对应的，然后再说图像传感器所生产的图像应该就我们所看到的物体的方向，也就是小人脑袋是朝上的，映射到屏幕上逆时针旋转90度后，我们便看到了上图所示的图像。 对于前置摄像头一般是和后置摄像头成180度的，但是前置摄像头采集的图像是经过镜像处理显示在屏幕上的，所以对于前置摄像头我们也是旋转90所以对于前置摄像头我们也是旋转90就可以正确的预览图像了 所以我们现在要使用setDisplayOrientation()来设置图片显示的方向和屏幕方向一致，Android 官网提供了一种设置图片预览方向和屏幕方向一致的设置操作 1234567891011121314151617181920212223242526272829public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) &#123; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); //获取屏幕的方向 int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degrees = 0; switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; &#125; int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; //前置摄像头 result = (info.orientation + degrees) % 360; result = (360 - result) % 360; // compensate the mirror &#125; else &#123; // back-facing //后置摄像头 result = (info.orientation - degrees + 360) % 360; &#125; camera.setDisplayOrientation(result); &#125; CameraInfo 是获取相机信息的API，官方是这样解释的：Information about a camera cameraInfo.orientation: The orientation of the camera image. The value is the angle that the camera image needs to be rotated clockwise so it shows correctly on the display in its natural orientation. It should be 0, 90, 180, or 270. 意思是说图像显示自然方向需要顺时针旋转的角度 (以上的图片引自一下网站 ：https://www.cnblogs.com/bugly/p/6108758.html，这篇文章总结的很好的，如果觉得我上面讲的不好可以看看这篇文章） 手机传感器方向 照片方向&emsp;&emsp;在设置好预览方向后，我们进行拍照，查看拍好的照片我们会发现拍摄的照片方向并不对，刚刚费了那么大的力气弄明白了预览方向的设置，发现其拍摄的照片方向并不生效，是不是很气，不过生气也没有办法啦，还得乖乖的来研究下怎么把拍摄好的照片方向整好才是。 在android api 中看setDisplayOrientation()时，对该方法有这样一句注解：This does not affect the order of byte array passed in onPreviewFrame(byte[], Camera), JPEG pictures, or recorded videos。 意思就是说不会调用onPreviewFrame 方法生成的JPEG图像，或者录制的视频产生作用。因此我们必须使用另外的方法来设置生成的照片的方向了。 首先获取到相机的设置服务类Camera.Parameters,这个类主要用于设置相机的显示效果，该类中会有setXXX方法供我们设置我们想要的效果，但是在这之前我们必须通过getXXX获取此效果允许我们设置的参数，如果我们设置了系统不支持的尺寸会发生不好的事情的（崩溃），设置好之后我们还要通过camera.setParameters(..)方法使我们上面设置的参数生效。 在Camera.Parameters中系统提供了设置照片方向的方法：setRotation (int rotation)： Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG Camera.PictureCallback. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If applications want to rotate the picture to match the orientation of what users see, apps should use OrientationEventListener and Camera.CameraInfo. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). 并且官方还给我们提供了获取图片该设置的角度的方法，以下是官方给出的方法 1234567891011121314public void onOrientationChanged(int orientation) &#123; if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) &#123; rotation = (info.orientation - orientation + 360) % 360; &#125; else &#123; // back-facing camera rotation = (info.orientation + orientation) % 360; &#125; mParameters.setRotation(rotation); &#125; 其中onOrientationChanged(int orientation)是OrientationEventListener中的回调方法，OrientationEventListener是监测手机（不是屏幕哦）旋转了多少度的，onOrientationChanged 中的orientation是指手机顺时针旋转的角度。通过以上计算后给相机设置计算后的角度，这个角度一定是0,90,180,270中的一个。 最后把相机的服务类设置给相机：camera.setParameters(mParameters); 一定要设置否则设置的参数将不会生效。 好了，通过以上解说我们解决了相机中的方向的问题，接下来我们聊一下相机中的尺寸问题。 Camera 中的尺寸问题&emsp;&emsp;开发相机时我们要保证预览控件的尺寸、图像预览的尺寸、照片的尺寸 的比例必须一致，否则我们不是看到在预览时界面有拉伸就是拍出来的照片有拉伸的问题。在相机中最常用到的预览比例是16:9和4:3,在我们确定了要设置的比例后分别通过设置该比例控件的大小、camera的预览尺寸和照片的大小后，就可以实现正常的预览和拍摄正常图片的功能了。 设置控件的尺寸可以通过在自定义view中重写onMeasure方法设置，下面给出一种设置预览控件大小的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;// super.onMeasure(widthMeasureSpec, heightMeasureSpec); int previewWidth = MeasureSpec.getSize(widthMeasureSpec); int previewHeight = MeasureSpec.getSize(heightMeasureSpec); boolean widthLonger = previewWidth &gt; previewHeight?true:false; int longSide = (widthLonger ?previewWidth : previewHeight); int shortSide = (widthLonger ? previewHeight : previewWidth); if (Math.abs((mRatio - (16 / 9d))) &lt; Util.DEVIATION)&#123; Log.d(TAG, "onMeasure: 16:9"); if (longSide &lt; shortSide*mRatio)&#123; longSide = Math.round((float) (shortSide * mRatio) / 2)* 2; &#125;else &#123; shortSide = Math.round((float) (previewHeight / mRatio) / 2) * 2; &#125; &#125;else &#123; Log.d(TAG, "onMeasure: 4:3"); if (longSide &gt; shortSide * mRatio)&#123; longSide = Math.round((float) (shortSide * mRatio) / 2) * 2; &#125;else &#123; shortSide = Math.round((float) (previewHeight / mRatio) / 2) * 2; &#125; &#125; if (widthLonger)&#123; previewWidth = longSide; previewHeight = shortSide; &#125;else &#123; previewHeight = longSide; previewWidth = shortSide; &#125; int marginTop = getResources().getDimensionPixelOffset(R.dimen.surface_margin_top); FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams(); if (mRatio &lt; Util.FULL_SCREEN)&#123; params.setMargins(0,marginTop,0,0); &#125;else &#123; params.setMargins(0,0,0,0); &#125; setLayoutParams(params); setMeasuredDimension(previewWidth,previewHeight); &#125; public void setRatio(double ratio)&#123; Log.d(TAG, "setRatio: ratio = "+ratio); if (mRatio != ratio)&#123; mRatio = ratio; requestLayout(); &#125; &#125; 接下来我们要设置相机的预览尺寸和照片尺寸了， 获取ParametersmCamera.getParameters() 设置预览大小和图片大小123456789101112131415161718192021public void setPreviewSize(double ratio)&#123; Camera.Size previewSize = getAppropriateSize(mParameters.getSupportedPreviewSizes(),ratio); Log.d(TAG, "setPreviewSize: preview width = "+previewSize.width+"; height = "+previewSize.height); mParameters.setPreviewSize(previewSize.width,previewSize.height); Camera.Size picSize = getAppropriateSize(mParameters.getSupportedPictureSizes(),ratio); Log.d(TAG, "setPreviewSize: pic width = "+previewSize.width+"; height = "+previewSize.height); mParameters.setPictureSize(picSize.width,picSize.height); &#125; //这里只是简单的筛选了适合比例的尺寸，自己写时可以使用更加严谨的筛选规则， public static Camera.Size getAppropriateSize(List&lt;Camera.Size&gt; sizeList,double ratio)&#123; Camera.Size result = null; for (Camera.Size size:sizeList)&#123; if (Math.abs(ratio - size.width *1.0d / size.height) &lt; DEVIATION)&#123; result = size; &#125; &#125; Log.d(TAG, "getPreviewSize: ratio = "+ratio+"; result width = "+result.width+"; height = "+result.height); return result; &#125; 将设置好参数的Parameters 设置给相机mCamera.setParameters(mParameters); 结合上面方向的设置，我们就可以实现方向正确自定义比例的的照片了。 自己写了一个小demo供大家参考： https://github.com/AndLollipop/huahua_Camera/tree/master/huahua_Camera_02 在下一篇中会继续讲解相机中聚焦和人脸识别的实现，请继续关注哦。]]></content>
      <categories>
        <category>技术周</category>
        <category>Camera开发</category>
      </categories>
      <tags>
        <tag>Camera开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintSet完全解析]]></title>
    <url>%2F2018%2F01%2F13%2F20180113_ConstraintSet%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在看这篇文章的tx，如果想了解ConstraintLayout的使用请移步：constraintlayout完全解析 官方网址：https://developer.android.com/reference/android/support/constraint/ConstraintSet.html ConstraintSet对控件影响&emsp;&emsp;对于ConstraintSet，官方文档解释到它是用来存储约束和将这些约束附加到ConstraintLayout上，之后又给了一个简单的小例子讲解了一下ConstraintSet的使用，这里也将官网代码一并拷出 12345678910111213141516171819202122ConstraintSet mConstraintSet1 = new ConstraintSet();ConstraintSet mConstraintSet2 = new ConstraintSet();ConstraintLayout mConstraintLayout;boolean mOld = true;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Context context = this; mConstraintSet2.clone(context, R.layout.state2); setContentView(R.layout.state1); mConstraintLayout = (ConstraintLayout) findViewById(R.id.activity_main); mConstraintSet1.clone(mConstraintLayout);&#125;public void foo(View view) &#123; TransitionManager.beginDelayedTransition(mConstraintLayout); if (mOld = !mOld) &#123; mConstraintSet1.applyTo(mConstraintLayout); &#125; else &#123; mConstraintSet2.applyTo(mConstraintLayout); &#125;&#125; &emsp;&emsp;就是这个样纸的，看起来很清晰，从将约束存储到ConstraintSet中到为ConstraintLayout设置一个新的约束，全程毫无尿点，但是运行之后发现有个类很强大，那就是TransitionManager，这个类用来管理开始场景和结束场景的过渡动画的，对于TransitionManager类本文最后将会讲解。 ConstraintSet类集成了约束的方法，这些方法和在xml里面是同样的效果，当然还有一些约束方法放到了ConstraintLayout.layoutParams里面，Ok,直接上效果 在之前要做这么一个效果可能要使用属性动画来实现，会有很多的计算和控制，在ConstraintSet里面完全不用，在保证使用一层ConstraintLayout布局嵌套的情况下来做各种动画确实感觉舒服了许多，代码实现起来很简单。 123456789101112131415161718192021222324constraintlayout = findViewById(R.id.constraintlayout);set.clone(constraintlayout);normal.clone(constraintlayout);iv_img.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; TransitionManager.beginDelayedTransition(constraintlayout); if (flag) &#123; set.connect(R.id.iv_img, ConstraintSet.LEFT, ConstraintSet.PARENT_ID, ConstraintSet.LEFT); set.connect(R.id.iv_img, ConstraintSet.TOP, ConstraintSet.PARENT_ID, ConstraintSet.TOP); set.connect(R.id.iv_img, ConstraintSet.RIGHT, ConstraintSet.PARENT_ID, ConstraintSet.RIGHT); set.connect(R.id.iv_img, ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM); set.constrainHeight(R.id.iv_img, 0); set.constrainWidth(R.id.iv_img, 0); set.setDimensionRatio(R.id.iv_img, "W,1:1"); set.applyTo(constraintlayout); flag = false; &#125; else &#123; flag = true; normal.applyTo(constraintlayout); &#125; &#125;&#125;); 这里需要注意的是connect所传的参数，再加上上一篇的ConstraintLayout使用理解这些东西就小case了，这里需要定义两个ConstraintSet控制一个正常一个放大效果，当然你可以像在属性动画那样添加一个加速器。 12345// API 19才会起作用Transition changeBounds = new ChangeBounds();changeBounds.setDuration(1000);changeBounds.setInterpolator(new BounceInterpolator());TransitionManager.beginDelayedTransition(constraintlayout, changeBounds); OK，对于这些还是不够的，还需要结合ConstraintLayout.LayoutParams来操作，就像ViewGroup.LayoutParams一样 123params = (ConstraintLayout.LayoutParams) ivLB.getLayoutParams();params.circleRadius = params.circleRadius + number;ivLB.setLayoutParams(params); 这里和在布局中操作圆定位效果是一样layout_constraintCircle : 约束控件的id layout_constraintCircleRadius : 该控件中心点和约束控件中心点的距离 layout_constraintCircleAngle : 角度 ConstraintSet对布局影响ConstraintSet在操作布局的时候非常简单，只需要将一个布局生成一个Scene场景，然后场景进行场景之间的切换即可，效果： 12before.clone(constraintLayout);after.clone(this, R.layout.activity_layout02_after); 通过布局初始化ConstraintSet,其他操作和上面一样就可以来回切换布局了 TransitionManager解析在上面的例子中都用到了TransitionManager，官方解释到这个类用来管理场景变化所引起的转换集，其中调用对象的setTransition(Scene, Transition) 或setTransition(Scene, Scene, Transition)使一种场景向另一种场景进行转化。TransitionManager的转化有两种形式 TransitionManager.go(scene1); transitionManager.transitionTo(scene3) 在开始之前先来介绍一下Scene（场景） A scene represents the collection of values that various properties in the View hierarchy will have when the scene is applied. A Scene can be configured to automatically run a Transition when it is applied, which will animate the various property changes that take place during the scene change. 这个类存储着一个根view下的各种view的属性。通常使用getSceneForLayout (ViewGroup sceneRoot,int layoutId,Context context)来获取实例。 123mScene1 = Scene.getSceneForLayout(relativelayout, R.layout.transition_scene1, this);mScene2 = Scene.getSceneForLayout(relativelayout, R.layout.transition_scene2, this);mScene3 = Scene.getSceneForLayout(relativelayout, R.layout.transition_scene3, this); 场景有了，接下来的就是使用transitionManager进行转化了。默认情况下转化使用了autotransition,如果希望有不同的转换行为，可以在代码中进行设置,也可以在xml里面进行设置 代码进行设置 类似于ChangeBounds类的还有以下几种，他们都是继承Transiton类 ChangeBounds:边界创建移动和缩放动画ChangeTransform:创建缩放和旋转动画ChangeClipBounds:View的剪切区域setClipBound(Rect rect)ChangeImageTransform:ImageView的尺寸动画Fade,Slide,Explode:visibility的子类，渐入，滑动，爆炸动画AutoTransition:TransitionManager的默认动画 布局中进行设置 在XML资源文件里面的res目录声明，transitionManager标签里面包含transition标签，描述从一个场景到另一个场景的转化,例如： 12345&lt;transitionManager xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;transition android:fromScene="@layout/transition_scene1" android:toScene="@layout/transition_scene2" android:transition="@transition/changebounds"/&gt;&lt;/transitionManager&gt; 1234TransitionInflater inflater = TransitionInflater.from(this);transitionManager = inflater.inflateTransitionManager(R.transition.transition_mgr, relativelayout);&#125;transitionManager.transitionTo(mScene1); 上面的情况是有明确场景的时候来使用，还有一种就是修改控件的宽高等部分属性值则使用beginDelayedTransition，这种形式不是一个真正的场景，通过调用TransitionManager的beginDelayedTransition的方法来告诉TransitionManager在下一帧进行过渡变换，在APIDemo中也有相应的例子 12345TransitionManager.beginDelayedTransition(relativelayout);setNewSize(R.id.iv_kongjian, 30, 30);setNewSize(R.id.iv_qq, 30, 30);setNewSize(R.id.iv_wechat, 30, 30);setNewSize(R.id.iv_tw, 30, 30); 效果和上面类似，下面将给出源码地址，感兴趣tx可以去试试。https://github.com/AndLollipop/ConstraintSet]]></content>
      <categories>
        <category>技术周</category>
        <category>玩转UI</category>
      </categories>
      <tags>
        <tag>玩转UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera之[预览类]]]></title>
    <url>%2F2018%2F01%2F07%2F20180107_Camera%E4%B9%8B%E9%A2%84%E8%A7%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp; 做相机开发已经有一年了，一直没写啥，为啥呢，懒！不说了，还是开写吧，要不钱全都充公了ε(┬┬﹏┬┬)3。 SurfaceView TextureView GLSurfaceView SurfaceTexture先大概说一下上面几个看上去非常类似的类他们的作用和区别 SurfaceView : SurfaceView 具有独立的绘图表面，Z轴位置是小于用来其宿主Activity窗口的Layer的Z轴位置，因此SurfaceView的UI就可以在一个独立的线程中进行绘制，同时，也有一个缺点就是显示不受view属性的控制，如不能设置透明度，不能应用动画。 TextureView：同SurfaceView一样是在单独的线程中进行绘制的，但是其将内容流直接投影到View中，作为View hierachy中的一个普通View，因此可以普通View一样进行移动，旋转，缩放，动画等变化，但是TextureView必须运行在开启了硬件加速器的窗口，其消耗的内存更高，据说还会有1~3帧的延迟。 GLSurfaceView：其继承自SurfaceView，它可以看作是SurfaceView的一种典型使用模式。在SurfaceView的基础上，它加入了EGL的管理，并自带了渲染线程。 SurfaceTexture：和上几个不同，他并不是一个View，从命名中也可以看出来，它是一个Texture，可以理解为View的中间件，可以对采集的数据进行处理，然后再交给特定的View显示。 上面大概介绍了这几个类的特点，在接下来相机开发的demo中采用的是SurfaceView进行预览。如果想更深入的了解以上几个类的区别可以看这篇文章 Android 5.0(Lollipop)中的SurfaceTexture，TextureView, SurfaceView和GLSurfaceView http://blog.csdn.net/jinzhuojun/article/details/44062175 SurfaceView 实现相机预览使用SurfaceView实现相机的预览主要有以下几步： 初始化SurfaceView,并获取其获取SurfaceHolder 实现SurfaceHolder.Callback，并为SurfaceHolder设置Callback 在SurfaceView创建之后，也就是Callback 回调surfaceCreated(SurfaceHolder surfaceHolder)之后为Camera设置PreviewDisplay，并开始预览 首先，我们实现了自己的previewview，以便以后我们实现比例设置操作 12345678public class PreviewSurfaceView extends SurfaceView &#123; private static final String TAG = "PreviewSurfaceView"; public PreviewSurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); &#125;&#125; 这里我们的操作很简单，只需要简单的继承SurfaceView实现其构造函数即可，对于其holder设置的Type，由于没有找到官方的解释，参考其他博客有以下说法 &emsp;&emsp;SURFACE_TYPE_NORMAL：用RAM缓存原生数据的普通Surface&emsp;&emsp;SURFACE_TYPE_HARDWARE：适用于DMA(Direct memory access )引擎和硬件加速的Surface&emsp;&emsp;SURFACE_TYPE_GPU：适用于GPU加速的Surface&emsp;&emsp;SURFACE_TYPE_PUSH_BUFFERS：表明该Surface不包含原生数据，Surface用到的数据由其他对象提供，在Camera图像预览中就使用该类型的Surface，有Camera负责提供给预览Surface数据，这样图像预览会比较流畅。如果设置这种类型则就不能调用lockCanvas来获取Canvas对象了。 接着实现一个相机的管理类，把相机的操作放到此类中 1234567891011121314151617181920212223242526272829303132333435363738394041public class CameraManager &#123; private static final String TAG = "CameraManager"; private Camera mCamera; public Camera getCamera()&#123; return mCamera; &#125; public void openCamera(int cameraId)&#123; Log.d(TAG, "openCamera: cameraId = "+cameraId); mCamera = Camera.open(cameraId); &#125; public void setPreviewDisplay(SurfaceHolder holder)&#123; Log.d(TAG, "setPreviewDisplay: camera = "+mCamera); if (mCamera != null)&#123; try &#123; mCamera.setPreviewDisplay(holder); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void release()&#123; Log.d(TAG, "release: camera = "+mCamera); if (mCamera != null)&#123; mCamera.stopPreview(); mCamera.release(); mCamera = null; &#125; &#125; public void startPreview()&#123; Log.d(TAG, "startPreview: camera = "+mCamera); if (mCamera != null)&#123; mCamera.startPreview(); mCamera.setDisplayOrientation(90); &#125; &#125;&#125; 在startPreview中，我们设置了mCamera.setDisplayOrientation(90)，否则你看到的图形就是这样的 这是由于屏幕的方向和相机的图形传感器方向不一致导致的，这个问题会在下一篇文章中加以解释 现在我们在MainActivity 中开启相机并启动预览 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback&#123; private static final String TAG = "MainActivity"; private CameraOP mCameraOp; private PerssionManager mPerssionManager; private PreviewSurfaceView mSurfaceView; private RelativeLayout mRoot; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); CameraManager manager = new CameraManager(); mCameraOp = new CameraOP(manager); mPerssionManager = new PerssionManager(); if (mPerssionManager.requesePerssion(this))&#123; mCameraOp.openCamera(); initSurfaceView(); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, "onResume: camera = "+mCameraOp.getCamera()); if(mPerssionManager.isCameraPerssionReady(this) &amp;&amp; mCameraOp.getCamera() == null)&#123; mCameraOp.openCamera(); initSurfaceView(); &#125; &#125; private void initView()&#123; mRoot = (RelativeLayout) findViewById(R.id.root); &#125; private void initSurfaceView()&#123; Log.d(TAG, "initSurfaceView: mSurfaceView = "+mSurfaceView); if (mSurfaceView == null)&#123; LayoutInflater inflater = LayoutInflater.from(this); View view = inflater.inflate(R.layout.camera_preview_layout,null); mSurfaceView = view.findViewById(R.id.camera_preview); SurfaceHolder holder = mSurfaceView.getHolder(); holder.addCallback(this); mRoot.addView(view); &#125; mSurfaceView.setVisibility(View.VISIBLE); &#125; @Override public void surfaceCreated(SurfaceHolder surfaceHolder) &#123; Log.d(TAG, "surfaceCreated: "); mCameraOp.setPreviewDisplay(surfaceHolder); mCameraOp.startPreview(); &#125; @Override public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; Log.d(TAG, "surfaceChanged: "); &#125; @Override public void surfaceDestroyed(SurfaceHolder surfaceHolder) &#123; Log.d(TAG, "surfaceDestroyed: "); mCameraOp.releaseCamera(); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, "onPause: "); mCameraOp.releaseCamera(); mSurfaceView.setVisibility(View.GONE); &#125; public class CameraOP&#123; CameraManager mCameraManager; public Camera getCamera()&#123; return mCameraManager.getCamera(); &#125; public void openCamera(int id)&#123; mCameraManager.openCamera(id); &#125; public void openCamera()&#123; openCamera(0); &#125; public CameraOP(CameraManager manager) &#123; this.mCameraManager = manager; &#125; public void setPreviewDisplay(SurfaceHolder holder)&#123; mCameraManager.setPreviewDisplay(holder); &#125; public void startPreview()&#123; mCameraManager.startPreview(); &#125; public void releaseCamera()&#123; mCameraManager.release(); &#125; &#125;&#125; 注意：相机的预览必须在surfaceChanged之后开始，并在surfaceDestroyed时结束预览并释放相机资源，相机资源不释放会导致其调用相机资源额应用无法正常打开 在代码中有关于权限的操作 mPerssionManager.requesePerssion(this)mPerssionManager.isCameraPerssionReady(this) 这是由于安卓6.0以后权限不仅要添加在Mainfest文件中，还要在使用的时候进行申请，关于权限的可以查看这篇文章，写的很清楚： Android 6.0 运行时权限管理最佳实践 http://blog.csdn.net/yanzhenjie1003/article/details/52503533/ 以上代码就可以实现相机的基本预览功能了，效果如下 此项目下载地址：https://github.com/AndLollipop/huahua_Camera 但是我们会发现界面被拉伸了，在接下来的文章中我们会介绍如何适配尺寸以及相机预览方向的问题。(┭┮﹏┭┮ 15大洋没了)]]></content>
      <categories>
        <category>技术周</category>
        <category>Camera开发</category>
      </categories>
      <tags>
        <tag>Camera开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不为人知的ConstraintLayout完全解析]]></title>
    <url>%2F2018%2F01%2F04%2F20180104_ConstraintLayout%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Constraintlayout这个控件出来也有一段时间了，从之前只是简单的使用，到现在算是有自己的理解。ConstraintLayout顾名思义约束布局，主要的功能就是用来约束子控件行为，类似RelativeLayout控件但更优于它，网上大多推荐使用预览界面进行操作，当然我也不排斥，但是工具永远都是用来用的，我们应该知其然又知其所以然。 在开始之前有必要分享一下自己所翻阅的资料 郭霖大神可视化操作 http://blog.csdn.net/guolin_blog/article/details/53122387 官方可视化操作 https://developer.android.com/training/constraint-layout/index.html 官方ConstraintLayout文档 https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html ConstraintLayout的使用&emsp;&emsp;以前我们在写布局都要嵌套好多层先不说做敲着有没有劲，就说性能上也会因为嵌套层数过多导致性能低下，针对这样的问题和初衷才有了学习ConstraintLayout的必要。 &emsp;&emsp;本文我们将从ConstraintLayout的使用、Barrier的使用、Guideline的使用、Placeholder的使用、Group的使用来揭开ConstraintLayout神秘的面纱，OK，开始我们的学习之旅 环境搭建&emsp;&emsp;在开始之前我们需要依赖ConstraintLayout库 123dependencies &#123; implementation 'com.android.support.constraint:constraint-layout:1.1.0-beta3'&#125; &emsp;&emsp;不知道要依赖那个版本的tx可以查看Googleblog，最好引用最新的库，不然有一些功能将无法使用，具体哪些功能看官网 https://androidstudio.googleblog.com/2017/10/constraintlayout-110-beta-3-is-now.html &emsp;&emsp;对于ConstraintLayout，官方文档中也通过几个方面来进行了讲解，可能是因为英文的原因加上官网例子很少导致很难去理解这些知识点，本文将和官方文档讲解思路一致对其进行顺序讲解，好了，写了这么多文字不来个图确实委屈了这么高大上的文章 &emsp;&emsp;可能大家想知道学了这个能做出什么，这里可以告诉你的是学了之后可以使用一层布局写出上面的效果并且可以使用一层布局做出更加复杂的效果。 相对定位（RelativeLayout Position）&emsp;&emsp;相对定位是一个ConstraintLayout布局的基本形态,这些约束允许您定位给定的控件相对于另一个控件。该约束可以是水平轴/垂直轴,具体的写法 12345678&lt;Button android:id="@+id/button02" android:layout_width="120dp" android:layout_height="180dp" android:text="button02" app:layout_constraintBaseline_toBaselineOf="@id/button01" app:layout_constraintLeft_toRightOf="@id/button01" app:layout_constraintRight_toRightOf="parent"/&gt; &emsp;&emsp;layout_constraintLeft_toLeftOf 意味着当前控件的左侧和某个控件的左侧对齐这里也提一下如果你使用拖拽方式将会在生成tools:layout_editor_absoluteY代码，这代码只是在可视化界面里面有效果 外边距 (Margins)&emsp;&emsp;在外边距ConstraintLayout提供了当约束控件gone掉之后所设置的margin，之所以有这个属性的存在大概Google也是考虑在gone掉一个控件的时候不想破坏掉其布局结构，来看用法 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom &emsp;&emsp;gone掉的控件会被解析成一个点，并忽略margin，当你为其设置了约束也还是会起作用，经常配合app:layout_goneMargin(在所约束控件gone掉才起作用)来使用 123456789101112131415&lt;android.support.constraint.ConstraintLayout&gt; &lt;Button android:id="@+id/button01" android:layout_width="100dp" android:layout_height="60dp" android:text="button01" /&gt; &lt;Button android:id="@+id/button02" android:layout_width="120dp" android:layout_height="100dp" android:layout_marginLeft="10dp" android:text="消失button01" app:layout_constraintLeft_toRightOf="@id/button01" app:layout_goneMarginLeft="110dp" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; &emsp;&emsp;需要注意的是这里的goneMarginLeft的值是自身MarginLeft+Gone掉Button的宽度+Gone掉Button的Margin 中心位置 (center position)&emsp;&emsp;在ConstraintLayout中如果想让子控件居中,在官方文档中称之为不可能发生，通过看官方的图我们可以理解为就好像一个控件左右两边同时用同样的力致使控件居中显示,就像下图所展示的那样 具体操作1234567&lt;Button android:id="@+id/button01" android:layout_width="100dp" android:layout_height="60dp" android:text="button01" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &emsp;&emsp;这样理解可能更加深刻一点，当然之所以这么去理解是因为官方又给了叫偏向的属性bias(需要结合约束来使用)，它的作用就是用来使约束更偏向于哪一边，默认是0.5 layout_constraintHorizontal_bias (0最左边 1最右边) layout_constraintVertical_bias (0最上边 1 最底边) 例如定义horizontal 0.9 则会在水平方向上向右偏移至90% 圆定位 (Circular Position)&emsp;&emsp;对于这个也是比较简单的，这里也来一张官方图，通过看官方图也就知道使用之后的效果啦~ 对于这张图我们需要去理解三个属性 layout_constraintCircle : 约束控件的id layout_constraintCircleRadius : 该控件中心点和约束控件中心点的距离 layout_constraintCircleAngle : 角度 这张图就需要理解一下通过设置之后有什么样的效果显示就可以了 尺寸约束 (dimensions constraints)在ConstraintLayout布局里为控件设置宽高提供了三种方式 确定尺寸 12dp WRAP_CONTENT 0dp，就等于MATCH_CONSTRAINT &emsp;&emsp;唯一不同的是MATCH_CONSTRAINT,在Google文档中说明对于包含在ConstraintLayout中的控件，不建议使用MATCH_PARENT。对于使用了MATCH_CONSTRAINT的控件将使该控件和约束控件的宽高一致，如果为其设置了margin属性在计算的时候也考虑在内 1234567891011121314151617&lt;android.support.constraint.ConstraintLayout&gt; &lt;Button android:id="@+id/button01" android:layout_width="200dp" android:layout_height="90dp" android:text="button01" /&gt; &lt;Button android:id="@+id/button02" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:text="Button02" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toBottomOf="@id/button01" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 给个效果体会一下： 与MATCH_CONSTRAINT一起使用的还有ratio比例,它代表这自身宽高比例。有两种取值： 浮点值，表示宽度和高度之间的比率 （2,0.5） width:height形式的比例 （5:1,1:5） &emsp;&emsp;当有一个维度设置为MATCH_CONSTRAINT（0dp）时，就可以根据比率来进行计算,如果两个维度均设置为MATCH_CONSTRAINT（0dp），这种情况下，系统会使用满足所有约束条件和比率的最大尺寸，如果需要根据一个维度的尺寸去约束另一个维度的尺寸则可以在比的前面加上W或者H来约束宽高，用逗号隔开 1234567891011121314151617&lt;android.support.constraint.ConstraintLayout&gt;&lt;Button android:id="@+id/button03" android:layout_width="0dp" android:layout_height="100dp" android:text="Button02" app:layout_constraintDimensionRatio="1:1" /&gt;&lt;Button android:id="@+id/button4" android:layout_width="0dp" android:layout_height="0dp" android:layout_marginTop="100dp" android:text="button4" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintDimensionRatio="H,2:1" app:layout_constraintTop_toBottomOf="@id/button03" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; &emsp;&emsp;这里用“H”表示以高度为约束，高度的最大尺寸就是父控件的高度，“2:1”表示高：宽 = 2 : 1.则宽度为高度的一半 链 (Chains)&emsp;&emsp;如何创建一个链呢，只需要一组控件通过双向链接在一起就构成了一个链，官方也给出了图形，这里也引用一下便于理解 这似乎并无卵用，然而重点是链的样式 &emsp;&emsp;这看起来似乎和rn的flex布局类似，如果你要是学过rn的话对于链会有更好的理解，下面来对每个样式进行说明 spread - 元素将被展开（默认样式） 加权链 - 在spread模式下，如果某些小部件设置为MATCH_CONSTRAINT，则它们将拆分可用空间 spread_inside - 类似，但链的端点将不会扩展 packed - 链的元素将被打包在一起。 孩子的水平或垂直偏差属性将影响包装元素的定位 对于使用该知识点的地方常见的就是底部的TAB平分屏幕,给个代码体会一下12345678910111213141516171819202122232425&lt;Button android:id="@+id/button01" android:layout_width="100dp" android:layout_height="wrap_content" android:text="button01" app:layout_constraintHorizontal_chainStyle="spread" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/button02" app:layout_constraintHorizontal_bias="1.0"/&gt;&lt;Button android:id="@+id/button02" android:layout_width="100dp" android:layout_height="wrap_content" android:text="button02" app:layout_constraintLeft_toRightOf="@id/button01" app:layout_constraintRight_toLeftOf="@id/button03" /&gt;&lt;Button android:id="@+id/button03" android:layout_width="100dp" android:layout_height="wrap_content" android:text="button02" app:layout_constraintLeft_toRightOf="@id/button02" app:layout_constraintRight_toRightOf="parent" /&gt; Barrier、Guideline的使用&emsp;&emsp;为什么要放在一起来进行讲解呢？因为Barrier和Guideline都是虚拟视图，更重要的是都是用来进行约束控件。当然也有不同之处： Barrier是有多个View的大小来决定的，通过constraint_referenced_ids 用来指定哪些View来进行约束，barrierDirection 用来Barrier相对于约束View的方向 Guidelin在布局里面充当辅助线，android:orientation 决定线的方向是水平还是竖直方向,其它的属性 layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent 当orientation为水平的时候 begin=100dp 为距离顶部100dp有个辅助线 end=100dp 为距离底部100dp有个辅助线 percent=0.8 为距离顶部80%有个辅助线 好了，一图胜千言，让我们在搞一个ImageView位置在右下角类似FloatActionBar的效果123456789101112131415161718192021222324&lt;android.support.constraint.ConstraintLayout&gt; &lt;android.support.constraint.Guideline android:id="@+id/vertical_guideline" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.8" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/horizontal_guideline" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_percent="0.8" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher_round" app:layout_constraintLeft_toRightOf="@id/vertical_guideline" app:layout_constraintTop_toBottomOf="@id/horizontal_guideline" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; Placeholder的使用&emsp;&emsp;Placeholder顾名思义，就是用来一个占位的东西，它可以把自己的内容设置为ConstraintLayout内的其它view。因此它用来写布局的模版，也可以用来动态修改UI的内容。 &emsp;&emsp;每个PlaceHolder都设置了自己的app:content属性，比如app:content=”@+id/edit”，表示用id为edit的控件来填充这个位置，OK，通过下面的代码熟悉一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;android.support.constraint.ConstraintLayout&gt; &lt;android.support.constraint.Placeholder android:id="@+id/placeholder_action" android:layout_width="wrap_content" android:layout_height="wrap_content" app:content="@+id/kongjian" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;ImageView android:id="@+id/kongjian" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_kongjian" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/qq" /&gt; &lt;ImageView android:id="@+id/qq" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_qq" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintLeft_toRightOf="@id/kongjian" app:layout_constraintRight_toLeftOf="@id/tw" /&gt; &lt;ImageView android:id="@+id/tw" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_tw" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintLeft_toRightOf="@id/qq" app:layout_constraintRight_toLeftOf="@id/wechat" /&gt; &lt;ImageView android:id="@+id/wechat" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_wechat" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintLeft_toRightOf="@id/tw" app:layout_constraintRight_toRightOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 12345678constraintLayout = findViewById(R.id.constraintLayout);findViewById(R.id.kongjian).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; TransitionManager.beginDelayedTransition(constraintLayout); placeholder_action.setContentId(v.getId()); &#125;&#125;); &emsp;&emsp;另外注意一下，我们在实际开发中可能会将使用placeholder的模板单独拿出来，但是拿出来之后就没有了提示，这里我们可以使用tools:parentTag=”android.support.constraint.ConstraintLayout”，这样在编辑的时候就会让它按照ConstraintLayout来处理。 Group的使用&emsp;&emsp;该组件的可见性将应用于所引用的控件，这是一种便利的方法，可以轻松的隐藏一组窗口部件而无需以编程方式维护该集合，对于Group的使用比较简单，这里给出相应的使用代码，不多说，上代码12345678910111213141516171819202122232425262728&lt;android.support.constraint.ConstraintLayout&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button2" app:layout_constraintTop_toBottomOf="@id/button1" /&gt; &lt;Button android:id="@+id/button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="隐藏显示" app:layout_constraintTop_toBottomOf="@id/button2" /&gt; &lt;android.support.constraint.Group android:id="@+id/group" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="visible" app:constraint_referenced_ids="button1,button2" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 实战最后开始撸我们开始展示的布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;android.support.constraint.ConstraintLayout android:padding="8dp"&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_begin="20dp" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_begin="5dp" /&gt; &lt;ImageView android:id="@+id/img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/head" app:layout_constraintBottom_toTopOf="@id/name" app:layout_constraintLeft_toLeftOf="@id/guideline1" app:layout_constraintTop_toTopOf="@id/guideline2" /&gt; &lt;android.support.constraint.Barrier android:id="@+id/img_barrier" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="right" app:constraint_referenced_ids="img" /&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Lypop" android:textColor="@android:color/white" android:textSize="16sp" app:layout_constraintLeft_toLeftOf="@id/guideline1" app:layout_constraintRight_toRightOf="@id/img_barrier" app:layout_constraintTop_toBottomOf="@id/img" /&gt; &lt;android.support.constraint.Barrier android:id="@+id/name_barrier" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="bottom" app:constraint_referenced_ids="name" /&gt; &lt;TextView android:id="@+id/id" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:text="名字ID：123456789" android:textColor="@android:color/white" android:textSize="14sp" app:layout_constraintBottom_toTopOf="@id/sex" app:layout_constraintLeft_toRightOf="@id/img" app:layout_constraintTop_toTopOf="@id/guideline2" app:layout_constraintVertical_chainStyle="spread" /&gt; &lt;TextView android:id="@+id/sex" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:text="性别：man" android:textColor="@android:color/white" android:textSize="14sp" app:layout_constraintBottom_toTopOf="@id/sign" app:layout_constraintLeft_toRightOf="@id/img" app:layout_constraintTop_toBottomOf="@id/id" /&gt; &lt;TextView android:id="@+id/sign" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:text="个性签名：我思故我在" android:textColor="@android:color/white" android:textSize="14sp" app:layout_constraintBottom_toBottomOf="@id/name_barrier" app:layout_constraintLeft_toRightOf="@id/img" app:layout_constraintTop_toBottomOf="@id/sex" /&gt; &lt;ImageView android:id="@+id/bottom1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_tw" app:layout_constraintBottom_toTopOf="@id/share1" app:layout_constraintHorizontal_chainStyle="spread" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/bottom2" /&gt; &lt;ImageView android:id="@+id/bottom2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_qq" app:layout_constraintBottom_toTopOf="@id/share2" app:layout_constraintLeft_toRightOf="@id/bottom1" app:layout_constraintRight_toLeftOf="@id/bottom3" /&gt; &lt;ImageView android:id="@+id/bottom3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_kongjian" app:layout_constraintBottom_toTopOf="@id/share3" app:layout_constraintLeft_toRightOf="@id/bottom2" app:layout_constraintRight_toLeftOf="@id/bottom4" /&gt; &lt;ImageView android:id="@+id/bottom4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/share_wechat" app:layout_constraintBottom_toTopOf="@id/share4" app:layout_constraintLeft_toRightOf="@id/bottom3" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;TextView android:id="@+id/share1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="分享1" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_chainStyle="spread" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/share2" /&gt; &lt;TextView android:id="@+id/share2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="分享2" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/share1" app:layout_constraintRight_toLeftOf="@id/share3" /&gt; &lt;TextView android:id="@+id/share3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="分享3" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/share2" app:layout_constraintRight_toLeftOf="@id/share4" /&gt; &lt;TextView android:id="@+id/share4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="分享4" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/share3" app:layout_constraintRight_toRightOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; &emsp;&emsp;这里面有一点需要注意的是，如何才能将下面的名字和头像居中，这里采用的是Barrier的特性，只需要给名字控件添加向左依赖和向右和Barrier的依赖即可居中，看下图 结束语&emsp;&emsp;OK，ConstraintLayout就讲解完毕，虽然这些可以通过拖拽来进行操作可能还会完成的更好，但是还是那句话我们要做到知其然又知其所以然。 我思故我在 源码下载地址：https://github.com/AndLollipop/ConstraintLayout 修正1、在头像和下面的名字可以让TextView左右和ImageView进行约束来达到文字和图片中间对齐 1234567891011121314151617181920&lt;ImageView android:id="@+id/img" android:layout_width="62dp" android:layout_height="60dp" android:layout_marginLeft="30dp" android:layout_marginRight="20dp" android:src="@mipmap/head" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@id/barrier" app:layout_constraintTop_toTopOf="@id/guideline1" /&gt;&lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="hahhjha" app:layout_constraintLeft_toLeftOf="@id/img" app:layout_constraintRight_toRightOf="@id/img" app:layout_constraintTop_toBottomOf="@id/img" /&gt;]]></content>
      <categories>
        <category>技术周</category>
        <category>玩转UI</category>
      </categories>
      <tags>
        <tag>玩转UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在北京的三年和即将到来的2018]]></title>
    <url>%2F2017%2F12%2F25%2F20171231_2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前话&emsp;&emsp;很久以前就想写一些总结性的东西了，奈何自己的执行力总是慢那么一丢丢，但是现在终于在老头的引导（威胁）下开始了，这篇文章也是会很荣幸的成为我的第一篇总结性的文章。 这三年生活篇&emsp;&emsp;2017年是我来北京的第三年了，几年里，自己从一个在校学生转变为一个万千打工者中的一员，在这个过程中也从一个人到现在的两个人。 2015年由于自己的分数足够(￣▽￣)，很开心的出来找实习的工作，虽然找工作的过程并没有自己想象的顺利，但是经过自己的努力还是在北京找到了一份合适的实习工作，记得刚来时是三个同学一起租住在后厂村那，由于自己年少无知，在看到租住的环境时也是失落了一两天，不过这个很快就在自己认清现实后自己修复了（哎呀，还真是佩服自己的自我修复能力biu~biu~biu~），后来由于某些原因我和一个室友又得出去找房子了，那是我们刚去不太敢请假，只能在白天在各种租房子的网站找自己认为合适的房子，晚上下班马上奔出去在中介的带领下各个小区奔波着看房子，但是看了几天后我们发现自己并不适合西二旗地段的房子，于是我们就很有自知之明的放弃在类似的地段找房子了，开始转战城农村，最后在表哥的帮助下终于找到了适合我们的房子，在那里我和我的小伙伴住了一年，早上最爱吃的就是那个2.5夹鸡蛋和豆皮的烧饼，甚至有时我们会多买一个带到公司中午吃，现在想想也还是很想吃的，哈哈！这一年的生活很简单，上班，逛街，回家，但是在这一年自己也掌握了很多基本的技能，譬如坐地铁啦，坐公交了，还有看手机地图啦，坐电梯等等~~（不要嘲笑我，因为我老家的生活真的很单纯），就这样在我和小伙伴的互相陪伴下第一年的北京生活也就结束了。 &emsp;&emsp;2016年春节后，又和小伙伴在实习的公司工作了将近一个月，我们的实习已经到期了，要开始找正式的工作，由于工作原因也只能被迫的各奔东西了，哦不，准确的说应该是各奔南北了，那段时间自己真的很压抑啊，毕竟陪自己一年一起八卦的小伙伴走了，还要面对找工作的压力，不过感觉生活对我还是蛮好的，因为就在那段时间老头出现了，他给了我很多，关心、鼓励和理解，当然这些都是通过打电话或者QQ完成的，因为我们就是在确定关系也是在手机上完成的，直到一个月以后我们才见了一年多以来的第一面，说实话我已经不记得他长啥样子了。一个月后，由于毕业设计我回了学校，我和老头见面了，记得那天傍晚由于感觉周围的氛围有点尴尬，又由于自己有点紧张所以就在一直的说话，而老头呢就在旁边听着，应该是并插不上话吧，晚上回到宿舍老头居然和我说觉得我可爱，我现在也终于找到了和老头在一起时自己话多的原因了，估计是还想被夸奖吧，so,老头，你懂得。 &emsp;&emsp;之后毕设结束了，答辩也结束了，在北京这边也找到了一份工作，虽然那份工作并不是很理想，但是在那里我认识了漂亮的燕燕，坚强的悦悦，任性的滴滴，可爱的蕊蕊，出谋划策的盟主，很感谢大家在那段时间的帮助和带给我的正能量。在2016剩下的时间里我还是独自一人在北京，因为老头决定留在学校考研，那段时间我会抱怨老头，因为在自己加班回家时看到那些被自己男盆友在接的女生时自己就顿生委屈（没错，就是来的这么快），然后回去如果老头再打电话过来的话就会被我臭骂一顿，等第二天自己又会自我反省，以后自己不能这样了，老头自己在学校压力也很大不是吗？我就是这么纠结。就这样2016也一点点的过去了，在这一年里我毕业了，第一次谈恋爱，第一次工作通宵，第一次认识了几个除同学之外的好朋友。 &emsp;&emsp;2016年的年底由于工作量太大，时常要通宵，自己的身体感觉也出现了不适，便决定换一份工作，由于之前一起的小伙伴的公司正在招人，而且感觉环境和工作地点也比较合适，便换到了现在的公司。2017年，老头考研结束后也来到北京了，感觉那时我和老头才真正的开始谈恋爱，我们会经常见面，约会的地点就是马路和天桥，虽然每次回来都是一身土，但是还是会很开心。后来老头也工作了，在一起的时间也变多了，在这段时间我们从开始争吵不断到现在依然争吵不断但会几秒后就和好，从开始的老头做饭把锅烧着到现在掌握调了500度大法，从开始早餐不固定到现在每天早上一个玉米一个鸡蛋（只限于我自己享受如此丰厚的待遇），前几天小伙伴说我比以前漂亮了，和闺蜜聊天说我越来越可爱了，这其中老头的功劳是功不可没的，以后老头老了我也会对老头一样的好ヽ(✿ﾟ▽ﾟ)ノ。这一年中我收获最多的是爱情和美好的心情，谢谢你可爱的老头，么么哒！ &emsp;&emsp;这三年中，我的生活变得独立，找到了一个爱我的和我爱的老头，虽然有些不太如意的地方，但是我认为保持乐观的心态和不停止的脚步生活一定会如我所愿！ 工作篇&emsp;&emsp;在上面自己也大概做了自己这三年的工作总结，在这段时间里自己一共在三家公司工作过，第一家实习的公司，在那里也认识很多优秀的长辈，我们组的每个人对我都很好，正因为那样才让我在那里过得很开心的同时也学到了很多技术和非技术的好习惯，这些好的习惯应该会影响我整个的编码阶段。第二家公司学到的更多的是自学和独自处理问题的能力，因为真正工作后自己就真正的是一个个体，必须能担任其自己负责的功能。在现在的公司中，其实我应该学到很多，但是由于自己这段时间的太贪玩导致自己学到的东西仅那么一点点，也希望自己能通过写这篇文章能对自己之后在学习带来引导。 &emsp;&emsp;这三年的生活缩写都在上面了，自己接下来的一年里要做的是和老头一起努力去突破自己，成为更优秀的和更开心的两个小北漂 即将到来的2018&emsp;&emsp;在已经到来的2018年，有以下几件事等待着被我完成 考研，在这一年自己将为考取北航在职研究生学习，首先要学习C，数据结构和数学，这个会在每周末腾出一天的时间去学习，还是要每天用零散的时间背英语单词，之后下半年开始正式的学习英语和政治，待书籍准备好后会把每个阶段学习在仔细做出规划。 看三本Android的基础书籍，为啥呢，因为自己的技术不连贯，希望通过阅读书籍把知识连贯起来 和老头一起学习Python,跟上时代的潮流😂 在春节前，完成Camera中的知识点整理 保持好的生活习惯每天吃鸡蛋😁；每天完成规定的运动；每天至少有一个小时学习；周末最晚睡到9点😢；尽量不和老头生气，毕竟年纪大了经不住被我气了👴 &emsp;&emsp;😭还是没有在2017年写完，受到惩罚了😭，希望在新的一年自己能按时完成计划，和老头一起迎接更优秀的我们！]]></content>
      <categories>
        <category>时光追溯</category>
      </categories>
      <tags>
        <tag>时光追溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收获2017,奔跑2018]]></title>
    <url>%2F2017%2F12%2F25%2F20171228_%E5%A5%94%E8%B7%91%E5%90%A7_2018%2F</url>
    <content type="text"><![CDATA[预热&emsp;&emsp;在开始阅读之前先戴上我们的耳机听一首音乐来缓解疲倦的你，开心的是这一年我们收获满满，不开心的是我们无任何收获。不管怎样你都无任何理由停下你的脚步、放下你手上的事去缅怀懊悔，时间不会等你，对手不会等你，终究你还是要去学习如何的活着。 写作初衷&emsp;&emsp;为了能留住自己的记忆，为了能和她守住彼此美好的回忆，希望每年都写一篇，一方面用来记住这一年美好的时光，另一方面就是用明年的计划来鞭策自己 生活小节奏&emsp;&emsp;我来北京差不多一年多了，从去年毕业大家都离开了待了4年的大学来北京打工，我独自留下准备考一次研，到今年3月份左右才找到一份工作，然后又跳槽来到了现在的这一家。工资是涨了一些，生活也多了一些惬意，自己也老练了许多。时间是个很神奇的东西，既开心长大又担心变老，难道人终究是一个矛盾的综合体吗？ 时光追溯&emsp;&emsp;我是一位苦逼的码农，在大四下半年认识了我对象,到今年7月份已经领证。虽然这里面有很多外在的因素促成我和她这么快能在一起，但是更重要的是我们都彼此相信对方是对的人，还记得我在石家庄考研的时候她在北京工作,那时候也许我和她对爱情并不成熟,她的世界我不懂,我的烦恼她也不懂。有过坚持,有过放弃,有过开心,也有过难过。然后我考研完来到北京找工作暂居好同学住所，投简历、面试成了家常便饭，当时自己内心并不是特别愿意上班总觉得自己能考上，找工作的这段时间我和她也是有见面的，她埋怨我没别人好、埋怨我什么都不懂，接着就是考研失败的消息,那时候的我就是迷茫,在然后就是找人托关系进了一家公司,那时候我别无选择,家里的、周围人的压力，那时候可以用5个字来形容自己的内心不甘于现状，但是现实往往是残酷的，至今想起来非常感谢她的坚持让我变得越来越好，我想对她说谢谢你 不论发生什么、也不论以后发生什么，都不要让自己心爱的人流泪。 公司小插曲&emsp;&emsp;上面说了我的第一家公司是托关系进来的，本想自己可以得到丰厚待遇可没想到工资低的可怜，那时候有什么办法，面对半年的考研空缺、技术空缺只能先在那里干着，开心的是在那里面认识了不错的小伙伴，他们对我也是棒棒哒，还有我的迪也是不错哒，看到他总让我想起我的初中同桌同学，不说啦！总之除了公司外，还是不错的一次经历。干了几个月之后我实在待不下去，当然了不能因为这些就否定这个公司的价值，只是因为这里没有我想要的生活。当然这期间她对我的支持和鼓励是最多的，我跳了，在1024那天我正式的离开了公司，离开了自己不喜欢的空气 &emsp;&emsp;1025我在新的公司入职，并继续开始了敲代码的生活。在这里学到了好多东西周围的同事也很和睦，更重要的是自己生活也有了一定的改善，到现在感觉生活很充实，公司的学习氛围还是棒棒哒。 技术小成就 架构思想 &emsp;&emsp;由MVC开发，到之后的MVP开发，最后是MVVM的学习，虽然自己在项目也使用了MVVM但是出现bug调试那是真的慢 UI特效 &emsp;&emsp;这一年也算是大部分都在高级UI，从5.0 v7/matrialdesign包提供的控件使用，接着是自定义控件View、ViewGroup的玩耍，最后是对UI绘制、事件传递、新控件源码分析，每段时间都有每段时间的感悟和思想碰撞 框架学习 &emsp;&emsp;ButterKnife的学习并能手写简单ButterKnife框架；Gson的学习并能手写简单JSon解析对象框架；对象数据库的学习并能手写面向对象数据库框架 NDK学习 &emsp;&emsp;NDK是我后期学习的科目，学习了C语言、C++语言以及Jni的开发，到最后NDK开发；用NDK开发还弄了个QQ变声特效，虽然在学习视频编解码那里有些不懂，之后还需要花费大量的精力去攻克这里 RN学习 &emsp;&emsp;RN之前也学习过，只不过之前公司没有带节奏就果断放弃了，RN也是最近几天才开始的，之所以这么着急也是因为自己不想在应用层待下去了，所以想往其他语言玩耍玩耍，学习进度也是很紧张的，目前到了React的生命周期学习 git &emsp;&emsp;Git也是在新公司才开始研究的，并弄了这么一个博客，使用git和别人一同去维护一同去分享技术，当然自己的这方面技术还是非常的欠缺，当然了也只有在用的过程中才能去学习，所以希望这个博客自己可以学到很多的git操作上的知识 其他 &emsp;&emsp;其他的也就是学习她公司的技术了，虽然和她一起学了一些但是也是不懂呀！可见我技术是多么的渣！！！！ 2018小期望 我希望我学的知识要多应用到项目中，即使自己公司的项目不用要多开发自己的上线项目并维护 我决定明年我要读12本书，5本技术、7本非技术，为啥是10本书呢？就是在过年之后到这时候正好每个月读一本，具体知道的书籍是Android开发艺术探索、React Native、JavaScript高级编程 我决定明年周六日多抽出点时间带她在北京去玩玩，例如买了羽毛球去打球、去逛公园。暂时先定这样的吧！反正不能宅在屋子里，如果有机会的话可以出北京市玩耍将会写在明年这时候的文章中 我将多多研究python并且将转入人工智能，这个转折我一定是要完成的也是必须完成的 明年我将用我的努力在去打造一个新的辉煌 &emsp;&emsp;虽然今年就要过去了，自己所得到的成就是很少，可能是因为从学习到从业者转变的原因，但是明年我将珍惜每一分每一秒去达到自己想要的境界。 未来的你将会感谢当初努力的自己 &emsp;&emsp;今天算是才写完，历时1个小夜晚2个小中午，前天是圣诞节，如果让我许个愿望的话，我希望她做一个开开心心的小吃货！ &emsp;&emsp;给她亮个照，美哒哒！]]></content>
      <categories>
        <category>时光追溯</category>
      </categories>
      <tags>
        <tag>时光追溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo markdown语法]]></title>
    <url>%2F2017%2F12%2F22%2F20171230_hexo%20markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录[TOC] #音乐 文字粗体 斜体 加粗斜体 删除线 外链接花花大世界 也可以这样 为段落设置阴影 设置阴影效果 多层嵌套 分割线 换行今天天气不错我们去玩吧 插入颜文字直接去该网址去copy就可以了颜文字网址 ヽ(￣ω￣(￣ω￣〃)ゝ 表情 静态表情表情的话直接去该网址直接copy就可以了好多表情 😀😁 动态表情的话可以使用我存入云存储的表情包，如果有其他的可以告诉我，我将其上传去 next主题自带一些样式可以使用http://fontawesome.io/examples/ blah blah blah blah blah blah Content (md partial supported) 代码一行代码欢迎使用花花世界 多行代码12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 列表有序列表 有序1 有序2 有序3 无序列表 Red Green Blue 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 图片]]></content>
      <categories>
        <category>markdown语法</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战(数据列表)]]></title>
    <url>%2F2017%2F07%2F03%2F20170703_Kotlin%E5%AE%9E%E6%88%98(%E6%95%B0%E6%8D%AE%E5%88%97%E8%A1%A8)%2F</url>
    <content type="text"><![CDATA[上一篇我们介绍了Anko库的使用，这里我们用Anko来做一个简单的RecyclerView列表 废话不说，直接撸代码 Start首先我们使用Anko在代码里面写一个RecyclerView，看代码12345678910 verticalLayout &#123; recyclerView &#123; id = R.id.main_rv //设置参数 anko为Activity扩展了act的字段 layoutManager = LinearLayoutManager(act)//layoutManager = LinearLayoutManager (this@MainActivity) padding = dip(20) adapter = this@MainActivity.adapter &#125; &#125; 接下来我们定义一个Adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MyAdapter(val ctx: Context, val items: ArrayList&lt;Resp&gt;): RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;()&#123; override fun onBindViewHolder(holder: MyViewHolder?, position: Int) &#123; val resp: Resp = items.get(position) Glide.with(ctx).load(resp.owner.avatar_url).into(holder?.iv) //？.代表holder可为空 holder?.tv1?.text = resp.name holder?.tv2?.text = resp.full_name &#125; override fun getItemCount(): Int = items.size override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): MyViewHolder &#123; //with : 在给定对象上调用lambda中的所有方法 val view = with(ctx)&#123; verticalLayout &#123; orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView &#123; id = R.id.iv lparams &#123; rightMargin = dip(20) leftMargin = dip(15) width = dip(80) height = dip(80) &#125; //设置默认图片 imageResource = R.mipmap.ic_launcher &#125; verticalLayout &#123; orientation = LinearLayout.VERTICAL textView &#123; id = R.id.tv1 textSize = 14f textColor = 0xff0000.opaque &#125; textView &#123; id = R.id.tv2 textSize = 16f textColor = 0x000000 &#125; &#125; &#125; &#125; val holder = MyViewHolder(view) return holder &#125; class MyViewHolder(itemView: View): RecyclerView.ViewHolder(itemView)&#123; //在给定的View上查找指定的id视图 val iv: ImageView = itemView.find(R.id.iv) val tv1: TextView = itemView.find(R.id.tv1) val tv2: TextView = itemView.find(R.id.tv2) &#125;&#125; 是不是很炫酷，当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果，具体的代码如下：12345678910111213141516171819202122232425class RecycleUI : AnkoComponent&lt;MyAdapter&gt; &#123; override fun createView(ui: AnkoContext&lt;MyAdapter&gt;): View = with(ui) &#123; verticalLayout &#123; orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView &#123; id = R.id.iv lparams &#123; rightMargin = dip(12) width = dip(80) height = dip(80) &#125; &#125; verticalLayout &#123; textView &#123; id = R.id.tv1 &#125; textView &#123; id = R.id.tv2 &#125; &#125; &#125; &#125;&#125; 这里我们也是使用with来生成相应的View视图 最后便是请求数据更新Adapter的操作了1234567891011121314async(kotlinx.coroutines.experimental.android.UI)&#123; //启动子线程 val data: Deferred&lt;ArrayList&lt;Resp&gt;&gt; = bg&#123; //读取assets里面的数据 val input = assets.open("data.json") val bytes = input.readBytes() input.close() //将得到的json串解析成对象并返回给data Gson().fromJson&lt;ArrayList&lt;Resp&gt;&gt;(String(bytes), getType&lt;ArrayList&lt;Resp&gt;&gt;()) &#125; items.clear() items.addAll(data.await()) //这里通过调用await方法会一直等待后台的执行，当执行完毕将赋值给item集合，并更新适配器 adapter.notifyDataSetChanged()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础第二弹]]></title>
    <url>%2F2017%2F07%2F02%2F20170702_Kotlin%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning anto库 https://github.com/Kotlin/anko/wiki 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 kotlin委托机制委托模式也是代理模式是软件设计模式中的一项基本技巧，在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理 在java和Android用到委托机制在AOP里，在java中使用继承InvocationHandler接口的方法来实现代理，而在Android中则使用AspectJ的方式来实现。在这里我们来讲解一下Kotlin的委托模式 类委托也就是上面讲的委托模式定义，然而在Kotlin中实现起来更加的方便更加的灵活，如： 123class MyList(list: ArrayList&lt;String&gt;) : Collection&lt;String&gt; by list &#123;&#125; 这种也是替代继承的方式，直接使用by关键字就将Collection的方法委托给list对象 属性委托在Kotlin中Delegates类内置了三种委托的方法，分别是lazy、notNull()、observable(“”)、vetoable(“”)、Map形式 lazy 用于进行懒加载，即第一次使用的时候才执行初始化操作 1234//当使用的时候才进行初始化（线程安全的）val list: ArrayList&lt;String&gt; by lazy &#123; ArrayList&lt;String&gt;()&#125; notNull() 使用于那些无法再初始化阶段就确定属性值的场合 12//初始化str,用于为空属性进行初始化的场景var str: String by Delegates.notNull&lt;String&gt;() observable() 观察者和java的观察者模式差不多 12345//oldValue是变化之前的值 newValue最新的值var str: String by Delegates.observable("")&#123;//初始值 property, oldValue, newValue -&gt; println("$&#123;property.name&#125; old=$oldValue new=$newValue")&#125; vetoable（）带条件的委托机制，通过返回的true和false来确定oldValue是上一个还是最初的 12345678910111213//返回true和observable是一样的效果var str1: String by Delegates.vetoable("")&#123; property, oldValue, newValue -&gt; println("$&#123;property.name&#125; old=$oldValue new=$newValue") true &#125;//返回false则标志oldValue永远为初始值var str2: String by Delegates.vetoable("")&#123; property, oldValue, newValue -&gt; println("$&#123;property.name&#125; old=$oldValue new=$newValue") false&#125; Map 通过一种全新的赋值方法给类属性进行赋值 123456class User(val map: Map&lt;String,Any?&gt;)&#123; val name: String by map val age: Int by map&#125;val user = User(mapOf("a" to 1)) 除此之外我们也可以自定义委托，具体定义可仿照notNull()委托 1234567891011private class NotNullVar&lt;T: Any&gt;() : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value: T? = null public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value ?: throw IllegalStateException("Property $&#123;property.name&#125; should be initialized before get.") &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; this.value = value &#125;&#125; 你也可以设置可读的委托机制，继承ReadOnlyProperty类即可 kotlin lambda表达式首先先给出一个小例子 12val action = &#123;i: Int, j: Int -&gt; println("i=$i j=$j")&#125;;action(1,2) 注意的是lambda表达式用{}包裹，箭头前面是参数的参数，箭头后面是函数体；从调用上来说比java简单并且优雅了许多，但是实际用途呢？我们可以为一个函数传一个lambda，如： 12345678910fun lambdaTest(arg1: Int, arg2: Int, oper: (a: Int, b: Int) -&gt; Int): Int &#123; var result: Int = Int.MIN_VALUE if (arg2 != 0) &#123; result = oper(arg1, arg2) &#125; return result&#125;fun main(args: Array&lt;String&gt;) &#123; lambdaTest(1, 2, &#123; a: Int, b: Int -&gt; a / b &#125;) 既然是传函数当然也可以传递一个函数进去，常使用::，这里延伸出函数的引用，另外还有属性的引用，这里 12345listOf(1, 2, 3).forEach(::println)var name = "1"val p = ::namep.set/get 当最后一个参数为lambda的时候，可以将大括号放在外面，如： 1lambdaTest(1, 2)&#123; a: Int, b: Int -&gt; a / b &#125; 用lambda表达式的情况还是挺多的，例如在集合中遍历等操作 12val list = arrayListOf(1, 2, 3) list.forEach &#123; value -&gt; &#125; kotlin 运算符重载表达式12345class Rmb(var num: Int) &#123; operator fun plus(rmb: Any?) &#123; &#125;&#125; 这样就可以使用Rmb(1) + Rmb(2)进行计算了，是不是很简单。这种操作和前面讲的中缀表达式一样，只不过中间的是运算符了而已 kotlin 注解与反射Kotlin的注解和java是类似的，先确定注解的类型，然后确定生命周期12345@Target(AnnotationTarget.FIELD, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)@Retention(AnnotationRetention.SOURCE)annotation class Path 使用的话直接在class前 fun前面 123@Path class UsePath(val p: String) &#123;&#125; Kotlin反射则通过12String::class.java String.javaClass 这两种方式来得到Class&lt;?&gt;对象，进一步可反射得到相应的属性和方法 调用第三方库使用Kotlin这里我们以ButterKnife为例，配置ButterKnife在Kotlin的环境 首先加入kotlin的classpath123456789ext.kotlin_version = '1.1.2-3' repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1' classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" &#125; 然后添加kotlin依赖12apply plugin: 'kotlin-android'compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version" 最后加入ButterKnife依赖，这里需要注意的是另外也添加kapt插件123apply plugin: 'kotlin-kapt' compile 'com.jakewharton:butterknife:8.6.0' kapt 'com.jakewharton:butterknife-compiler:8.6.0' 这样kapt会将ButterKnife的java代码转化为kotlin代码 至此环境就配置好了，当然你也可以在网上搜一搜，这里也就是做个笔记 Anko Dialog对于Anko的Dialog用的最多的也Toast的使用，在Anko中使用toast是相当的简单1234fun open_toast(view: View)&#123; toast("toast") longToast("long toast")&#125; 然后就是AlertDialog的使用也是一看就会用的那种12345678910111213fun open_alert(view: View)&#123;alert("Hi,I'm Roy","Have you tried turning it off and on again?")&#123; yesButton &#123; toast("yes") &#125; noButton &#123; toast("no") &#125;&#125;.show()//当然你也可以使用自定义的Viewalert&#123; customView&#123; editText() &#125;&#125;&#125; 当然还有其它的弹框这里就不一一介绍，具体请看官方 Anko Intent相比之前的Intent来说Anko提供的更加的方便，使用如下 startActivity(intentFor&lt;AnkoActivity01&gt;(&quot;id&quot; to 5).singleTop()) 其他的一些使用如下： Anko Log对于Log，Anko解释AndroidSDK提供的Log也是非常的简单，尽管方法需要你传递标签参数，但使用起来也是非常的简单，当然你也可以使用AnkoLogger来消除这一点 实现AnkoLogger的方式 info(&quot;this is second log info&quot;) //这种带lambda表达式的这种会去计算Log.isLoggable(tag, Log.INFO)是否为true，为true的话才打印 info { &quot;this is third log info&quot; } 使用其对象的方式 val logWithASpecificTag = AnkoLogger(&quot;lypop&quot;) logWithASpecificTag.info { &quot;this is Log info&quot; } 第一种Tag默认是类名，第二种可以自定义其Tag Anko helper你可以在你的项目中使用帮助者来简化你的代码，例如Color、Dimen等，颜色透明度直接色值.opaque就可以，尺寸的话直接使用dip(dipValue)、sp(spValue)就可以。在这里面还有一个就是applyRecursively()用来控制子View的操作，如：12345678910111213141516 verticalLayout &#123; textView&#123; text = "EditText01" backgroundColor = 0xff000.opaque textSize = 14f &#125; textView &#123; text = "EditText02" backgroundColor = 0x99.gray.opaque textSize = 23f &#125;&#125;.applyRecursively &#123;//如果是ViewGroup的话可以使用applyRecursively来为每个Child View进行设置 view -&gt; when(view)&#123; is TextView -&gt; view.textColor = Color.RED &#125; &#125; Anko CoroutinesAnko还提供了协程的用来做一些耗时的操作，提供的操作为bg{},具体代码如下： async(UI){//UI线程 val data: Deferred&lt;MyBean&gt; = bg {//后台线程 // Runs in background MyBean() } showData(data.await()) //await方法将一直等待bg返回的数据 } 为了防止内存泄漏我们常会使用弱引用，在Anko中使用弱引用方法如下： val ref: Ref&lt;AnkoActivity05&gt; = this.asReference() async(UI){ //ref替代了this@AnkoActivity05 ref().showData() } Anko Layout那我们先来说一下普通写Android布局有啥缺点 它不是类型安全的和不是空安全 它迫使您为每个布局都编写相同的代码 在设备上解析xml浪费CPU时间和电池 最重要的是它不允许代码重用 那Kotlin不行吗?为什么还要用anko呢？ 官方解释说Kotlin那种是解决了不能编程生成UI，但是用Kotlin代码写出来的UI难以维护所以才出现了anko库，具体相应的代码还请看官网。（其实也没必要看，毕竟出来了一种库必然有其存在的原因）123456789101112131415 verticalLayout &#123; padding = dip(30) button("say")&#123; onClick &#123;toast("Hello,$&#123;if (it is TextView) it.text else ""&#125;") &#125; &#125; button(R.string.app_name) button&#123; textResource = R.string.app_name &#125;.lparams &#123; //如果指定了 lparams 但是没有指定 width 或者 height，那么默认是 “wrapContent” width = matchParent topMargin = dip(10) horizontalMargin = dip(5) &#125;&#125; Activity没有显示调用setContentView，anko会自动为Activity设置Content View 这里列举了button的三种创建形式和为其设置参数当然在Activity/Fragment也会使用xml布局，anko也为我们提供了简单的创建控件对象的方式 对象的名字就是控件的ID 使用find(R.id.name)也可以 可以看出这几种都比Android的findViewById要舒适的多 当然代码中还可能会有 include 123include&lt;View&gt;(R.layout.something) &#123; backgroundColor = Color.RED&#125;.lparams(width = matchParent) &#123; margin = dip(12) &#125; 自定义View 123456789inline fun ViewManager.myView(init: MyView.() -&gt; Unit): MyView &#123; return ankoView(&#123; MyView(it) &#125;, 0, init)&#125;class MyView(ctx: Context) : View(ctx) &#123; fun test() &#123; &#125;&#125; 使用的时候和上面使用方法一样直接用myView{} 但是非常遗憾的是没有预览界面，虽然anko提供了支持插件，但非常遗憾的是仅支持AndroidStudio2.4+ 这样我们就创建了一个简单的布局1234567891011fun Context.sendSMS(number: String, text: String = ""): Boolean &#123; try &#123; val intent = Intent(Intent.ACTION_VIEW, Uri.parse("sms:$number")) intent.putExtra("sms_body", text) startActivity(intent) return true &#125; catch (e: Exception) &#123; e.printStackTrace() return false &#125;&#125; Anko SQLite在之前使用SQLiteOpenHelper，通常调用getReadableDatabase（）或getWritableDatabase（），但是您必须确保在接收的SQLiteDatabase上调用close（）方法。如果您从多个线程中使用它，则必须了解并发访问。 所有这一切都很艰难。 这就是为什么Android开发人员不太喜欢默认的SQLite API，而是更喜欢使用相当昂贵的包装器，如ORMs。 Anko提供了ManagedSQLiteOpenHelper 可以无缝替代默认的,当操作完毕之后就会自动关闭，在使用的时候需要去继承ManagedSQLiteOpenHelper1234567891011121314151617181920 class MySqlHelper(ctx: Context = MyApplication.getApplication(), name: String? = "db", factory: SQLiteDatabase.CursorFactory? = null, version: Int = 1) : ManagedSQLiteOpenHelper(ctx, name, factory, version) &#123;我们如果想让它成为线程安全的可以 companion object &#123; @Volatile private var helper: MySqlHelper? = null fun getInstance(): MySqlHelper &#123; if (null == helper) &#123; synchronized(MySqlHelper::class) &#123; if (null == helper) &#123; helper = MySqlHelper() &#125; &#125; &#125; return helper!! &#125; &#125; 然后我们就可以使用Anko提供的数据库操作了123456789101112131415161718192021222324 fun queryAll(): List&lt;Gps&gt; = use &#123; select(Gps.TABEL_NAME).exec &#123; parseList(classParser&lt;Gps&gt;()) //查询使用parserXX方法需要存在查询字段的相应构造方法 &#125;&#125; fun queryLonAfter(id: Long): List&lt;Double&gt; = use &#123; select(Gps.TABEL_NAME, Gps.LON).whereArgs("$&#123;Gps._ID&#125; &gt; &#123;id&#125;", "id" to id) .exec &#123; parseList(DoubleParser) &#125; &#125; fun deleteById(id: Long)&#123; use &#123; delete(Gps.TABEL_NAME, "$&#123;Gps._ID&#125; = &#123;id&#125;", "id" to id) &#125; &#125; fun updateById(id: Long) &#123; use &#123; update(Gps.TABEL_NAME, Gps.PROVIDER to "lbs").whereArgs("$&#123;Gps._ID&#125; = &#123;id&#125;", "id" to id).exec() &#125; &#125; 这里使用use来包裹，当里面的代码执行完毕就会自动关闭数据库 至此，Anko就讲解完毕，更多的内容还请阅读官方，Thanks♪(･ω･)ﾉ]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础第一弹]]></title>
    <url>%2F2017%2F07%2F01%2F20170701_Kotlin%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 Kotlin集合集合无非是list集合和map集合，如下：12val list = listOf(1, 2, 3, 4)val map = mapOf(1 to "a", 2 to "b", 3 to "c") 是不是很简单，但它只能去遍历不能去操作，why?首先我们以list为例，点进去看一下它里面只有get、indexof、iterator方法，这也就决定了它的职责就是去遍历 那如果想进度读写操作,就需要去使用mutableListOf、mutableMapOf来创建集合了 既然我们创建了一个集合，我们就需要对于进行遍历，和java不同的是kotlin使用了in来遍历123for(i in list)&#123; println("i=$i") &#125; 也可以使用forEach123list.forEach &#123; println("it=$it") &#125; 还有1234list.forEachIndexed&#123; index,i-&gt; println("index=$index i=$i") &#125; 等等。这时候我们可能会有疑问，forEach里面大括号里要写什么呢？其实它里面接受的是一个lamada表达式1234@kotlin.internal.HidesMemberspublic inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit &#123; for (element in this) action(element)&#125; 这里就需要说一下了，(T)-&gt;Unit表示接受一个T类型参数返回一个Unit类型的函数，Unit也就是java中void类型，我们在调用的时候需要传入{params-&gt;}这种式子，Kotlin规定当参数只有一个的时候可以不用写，默认是it,所以我们也可以这样写123list.forEach &#123;item-&gt; println("item=$item") &#125; 好了，list说完了，下面说说Map，我们在定义map的时候用到了to,其实是key to value的格式，to充当的是中缀表达式，我们也可以定义自己的中缀表达式 infix fun &lt;A,B&gt; A.with(that: B):Pair&lt;A,B&gt; = Pair(this,that) 这样我们就可以这样12val pair = 4 to "d" val (key,value) = pair; ok,集合就先到这里，更多操作可以实际去操作 Kotlin扩展函数 扩展属性扩展函数、扩展属性很简单，直接上例子123456val String.lastChar: Char get() = get(length - 1)inline fun String.show(): Unit &#123; println("String.show()")&#125; 直接使用类名.方法即可，调用的时候就可以”lypop”.show() Kotlin函数kotlin函数有个特点就是可以设置默认值1234567891011fun test(a: Int = 1, str: String = "") &#123; print("test(a: Int = 1, str: String = \"\")")&#125;fun test(str: String = "") &#123; print("test(str: String = \"\")")&#125;fun test(a: Int = 1, b: Int = 2, str: String = "") &#123; print("test(a: Int = 1, b: Int = 2,str: String = \"\")")&#125; 当你调用test()会执行最匹配的方法fun test(str: String = “”)，在kotlin也有java的可变参数，只需要在方法写入vararg item: Int即可 Kotlin可为空这个比较简单，先上代码12val str: String? = null str?.length 下面的调用也可以使用str!!.length的样式，具体？的使用在之后会经常用到，多多体会就好，这里不做过多的赘述 Kotlin字符串的使用字符串的操作这里以分割来说一下1234567val str = "com.lypop.android" val list = str.split(".") if(list is List)&#123; for(value in list)&#123; println("value=$value") &#125; &#125; 就是这么简单的一些调用，当然还有一些其他复杂的操作，例如12345678910val path = "E:\\md_workspace\\Kotlin_collection.md" val afterLast = path.substringAfterLast(".") //获取到md println("afterLast=$afterLast") val beforeLast = path.substringBeforeLast(":") println("beforeLast=$beforeLast") val missingValue = path.substringBeforeLast("?","missing value") //如果没有找到的话则返回第二个参数 println("missing Value=$missingValue") 是不是相比java的substring更加灵活了，当然对于这种字符串的操作会使用就可以了，当然不知道意思的话，可以进源码查看也可以百度最后在说两个比较常用的知识点 打印&amp;字符 12println("\$abc")println(""" $&#123;'$'&#125;abc """) 使用正则表达式 12345678val match = "(.+)\\.(.+)\\.(.+)".toRegex()val matchResult = match.matchEntire("com.lypop.one")val list1:List&lt;String&gt;? = matchResult?.destructured?.toList() if(list1 != null)&#123; for(str in list1)&#123; println("str=$str") &#125; &#125; kotlin类对于类，我们先要说下在Kotlin中接口有啥特点1234567interface OnClickListener&#123; val name: String fun test()&#123; println("OnClickListener test") &#125; fun action()&#125; 和java的接口相比，kotlin的接口更加强大还可以写方法的实现，还有一个那就是接口open类型的可以被直接继承123456789101112class Child1 : OnClickListener,OnClickListener1&#123; override val name: String = "" override fun test() &#123; super&lt;OnClickListener&gt;.test() &#125; override fun action() &#123; &#125; override fun action1() &#123; &#125;&#125; 当你需要在子类方法调用父类的方法的时候直接super即可 对于抽象类123456789abstract class ABParent&#123; abstract fun test()&#125;class ABChild: ABParent()&#123; override fun test() &#123; &#125;&#125; 也是直接可以继承的，里面的abstract方法默认是open修饰 对于普通类就需要给父类用open进行修饰才能进行继承，因为对于类来说默认是final类型的，接下来我们就需要对类进行一些研究，对于java类分为内部类、外部类、静态类等等，kotlin当然也会有区分123456789101112131415161718192021222324252627282930313233343536class ClassA&#123; var name: String = "lypop" class NestClass&#123; fun test()&#123; //name = "" 嵌套类不能访问外部类的属性和方法 &#125; &#125; //内部类 存在外部类的引用 可以访问外部类的属性和方法 inner class InnerClass&#123; fun test()&#123; name = "change Name" &#125; &#125; //创建伴生对象 companion object &#123; var comName = "aaa" fun companionTest()&#123; println("companionTest") &#125; &#125; //定义静态内部类 object InnerStaticClass&#123; fun test()&#123; comName = "===" &#125; &#125;&#125;//定义静态外部类object StaticOuterClass&#123; val age: Int = 22&#125; 这里我们需要注意： 嵌套类不能访问外部类的属性和方法,内部类才可以访问 因为kotlin没有static关键字，如果要在类中定义静态的方法和属性需要来创建伴生对象，在使用的时候可以ClassA.companion.comName也可以直接ClassA.comName访问 静态内部类可以访问伴生对象的属性和方法，就和java中静态内部类可以访问外部类定义的静态属性和静态方法是一样的 接下来一个便是匿名内部类的写法12345val obj = object: OnClickListener2&#123; override fun test() &#123; println("object test()") &#125;&#125; 该内部类实现了OnClickListener2的接口，将对象赋值给了obj 最后也就是Kotlin的数据类，和java中的Bean类一样，只有类属性和相应的get/set方法 data class Person(val name: String) kotlin类构造方法类的构造方法和java有些不同，kotlin分为主构造方法和次构造方法123456789101112131415class User(name: String) &#123;//主构造方法 var name: String = "" var pwd: String = "" //次构造器 constructor(name: String, pwd: String) : this(name) &#123; this.name = name this.pwd = pwd &#125; //初始化器 init &#123; this.name = name &#125;&#125; 这里需要注意的是： 次构造方法必须要去初始化主构造方法 当主构造方法需要权限等修饰的时候constructor必须要加上，其他的情况可以不写 对于初始化字段可以放在init初始化器中进行初始化]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Android的消息机制]]></title>
    <url>%2F2017%2F06%2F09%2F20170609_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言这篇文章我们来学习一下Handler的源码，说起Handler我们并不陌生，用的最多的就是更新UI了。然而Handler并不是专门用于更新UI的，它只是常被开发者用来更新UI 正文在开始之前我们需要对几个问题进行回答 为什么Android只能在主线程访问UI？ 因为在ViewRootImpl对UI操作进行了验证，这个验证的工作是由ViewRootImpl的checkThread方法来完成的123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 因为这一限制导致必须在主线程里面访问UI，但是又不能执行耗时的操作，这才有了Handler用于将UI工作切换到主线程进行操作 系统为什么不允许子线程更新UI呢？ 这是因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态 那为什么系统不为UI控件的访问加上锁机制呢？ 缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行 Handler的运行需要底层MessageQueue和Looper的支撑。 Handler：处理和分发消息MessageQueue：以队列的形式插入和删除消息，但是内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表Looper：消息循环器，如果有消息则将消息分发给Handler来处理 我们进入程序的入口main方法来看看给我们做了什么事情12345678910public static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在主线程中开启了Looper，所以我们在主线程不用去开启Looper，直接使用new Handler即可。主线程消息循环开启以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是H，final H mH = new H();使用饿加载的方式进行初始化主要包含了四大组件的启动和停止1234567891011121314151617181920private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; ......&#125; 当然ActivityThread通过AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行。 因为main方法已经开启了Looper，所以我们在使用的时候就不用开启Looper了，因为子线程里面没有开启Looper所以需要我们手动去开启才能在子线程里去处理消息123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; 我们可能会有疑问，我们在子线程里面直接new Handler就不可以吗？答案当然是不可以，我们来进入Handler的构造方法来探个究竟123456789101112131415161718public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在构造方法里面会调用Looper.myLooper()123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 这个方法其实是得到当前线程下的Looper对象，因为在子线程里面没有Looper对象所以会抛出异常（”Can’t create handler inside thread that has not called Looper.prepare()”），比较困惑的是ThreadLocal类是做什么用的呢？这个后续会说。 OK，在main方法里面既然调用了Looper.prepareMainLooper，那我们先从这里进行分析123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 这是Looper专门为主线程提供的方法，其实内部也是调用了prepare方法，由于主线程的Looper的比较特殊，Looper也提供了一个getMainLooper方法来获取主线程的Looper因为在main方法已经执行了prepareMainLooper方法，所以我们再在主线程调用的话就会抛出异常 进入prepare方法123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这里将创建一个Looper并存入ThreadLocal中，如果调用多次prepare方法则会抛出异常（Only one Looper may be created per thread） prepare只是创建Looper对象阶段，真正开启循环器的是Looper.loop方法123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ...... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ...... msg.recycleUnchecked(); &#125;&#125; 这个方法就是不断的去循环消息队列调用queue.next方法1234567891011121314151617181920212223242526272829303132333435363738Message next() &#123; ...... for (;;) &#123; synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; &#125; &#125; &#125; 如果消息不为空则取出并调用msg.target.dispatchMessage方法让handler去处理在往下看会看到msg.recycleUnchecked()，内部调用了Message的回收的方法所以我们就不需要手动进行回收了1234567891011121314151617181920212223void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 并没有进行回收而是将消息内容置空之后加入到消息缓存池中，这样当调用Message.obtain时如果缓存池有消息则直接取出 ok,我们在来看dispatchMessage方法123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 可见并不是所有消息都有handleMessage进行处理，分析一下 msg.callback != null：handler.post()方法 1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 当我们隔多长时间重复调用run方法的时候，handler.post是个不错的选择 Handler里Callback回调：new Handler(callback) 我们使用callback来创建一个对象而不需要派生Handler子类，如果不想派生子类的时候可以通过Callback来实现 handleMessage 12public void handleMessage(Message msg) &#123;&#125; 里面空实现需要我们进行消息的处理操作 处理消息的流程走通了，接下来我们来看一下发送消息的流程handler.sendMessage -&gt; enqueueMessage1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 添加消息到队列中的时候将handler赋值给了msg的target，ok,进入MessageQueue的enqueueMessage12345678910111213141516171819202122232425262728293031323334353637boolean enqueueMessage(Message msg, long when) &#123; synchronized (this) &#123; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装包性能优化]]></title>
    <url>%2F2017%2F06%2F06%2F20170606_%E5%AE%89%E8%A3%85%E5%8C%85%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言本章我们将讲解安装包的性能优化，在本篇文章中我们将按照普通压缩方式以及高级压缩来进行讲解。总之就是一个字：删！！删不了就尽量的变小。 普通压缩方式图片压缩图片：apk里面的资源图片 压缩图片svg图片：一些图片的描述，牺牲CPU的计算能力的，节省空间。使用的原则：简单的图标。webp:谷歌现在非常提倡的使用。保存图片比较小。VP8派生而来的。webp的无损压缩比PNG文件小45%左右，即使PNG进过其他的压缩工具压缩后，任然可以减小到PNG的28%。Facebook在用、腾讯、淘宝。缺点：加载相比于PNG要慢很多。 但是配置比较高。图片压缩工具：tinypng.com/图片压缩转换工具：isparta.github.io/ 资源动态加载比如：emoji表情、换肤、动态下载的资源、一些模块的插件化动态添加 Lint工具使用Lint工具删除无用的一些资源，包括：1）检测没有用的布局 删除2）未使用到的资源 比如 图片 —删除3）建议String.xml有一些没有用到的字符。 7zZip工具使用7zip进行极限压缩，具体的使用步骤(1) 下载7-zip安装文件 7-ZIP版本：9.20 x86 And x64 Windows(2) 将apk包解压到文件夹(3) 全选所有的文件，右键添加到压缩包(4) 压缩格式必须是zip格式(5) 压缩等级选择极限压缩(6) 压缩方法必须是Deflate（试了Deflate64,BZip2,LZMA,PPMd都无法正常安装）(7) 单词大小选择256(8) 将后缀改为APK即可 7zZip压缩算法对比 lib资源优化(1) 动态下载资源(2) 一些模块的插件化动态添加(3) so文件的裁剪和压缩 assets资源优化(1) 音频文件最好使用有损压缩的格式，比如采用opus、mp3等格式，但是最好不要使用无损压缩的音乐格式(2) 对ttf字体文件压缩，可以采用fontCreator工具只提取出你需要的文字。比如在做日期显示时，其实只需要数字字体，但是使用原有的字体库可能需要10MB大小，如果只是把你需要的字体提取出来生成的字体文件只有10KB。 Proguard混淆(1) 可以删除注释个不用的代码(2) 将java文件名改为短名a.java b.java(3) 方法名等 CommonUtil.getDisplayMetrix() =&gt; a.a() 高级压缩Proguard深度混淆我们将混淆之后的apk解压发现只是java文件的名字进行混淆，于是我们有了这样的疑问能不能讲res文件里的文件名也变成a.xml呢？答案是肯定的，那该怎么做呢？ 在开始之前我们需要了解一下apk编译原理Android应用程序主要由两部分内容组成：代码和资源。资源主要就是指那些与UI相关的东西，例如UI布局、字符串和图片等。代码和资源分开可以使得应用程序在运行时根据实际需要来组织UI。这样就可使得应用程序只需要编译一次，就可以支持不同的UI布局。这种特性使得应用程序在运行时可以适应不同的屏幕大小和密度，以及不同的国家和语言等。 aapt编译aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件。 通过图我们就可以看出：A. 除了assets和res/raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理。B. 除了assets资源之外，其它的资源都会被赋予一个资源ID。C. 打包工具负责编译和打包资源，编译完成之后，会生成一个resources.arsc文件和一个R.java，前者保存的是一个资源索引表，后者定义了各个资源ID常量。D. 应用程序配置文件AndroidManifest.xml同样会被编译成二进制的XML文件，然后再打包到APK里面去。E. 应用程序在运行时通过AssetManager来访问资源，或通过资源ID来访问，或通过文件名来访问。 其中resources.arsc文件，这个文件记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。我们可以将这个resources.arsc文件想象成是一个资源索引表，这个资源索引表在给定资源ID和设备配置信息的情况下，能够在应用程序的资源目录中快速地找到最匹配的资源。 resource.arsc文件里面的内容 resources_arsc二进制表resources.arsc一共有五种chunk类型，分别为TYPETABLE，TYPEPACKAGE，TYPE_STRING ,TYPETYPE，TYPECONFIG。 —table，是整个reousces table的开始，它的chunksize即是整个文件的大小。 —package，指的是一个package的开始，其实在resources,arsc是可以有多个package的。而packageID即是资源resID的最高八位，一般来说系统android的是1(0×01)，普通的例如com.tencent.mm会是127(0x7f)，剩下的是从2开始起步。当然这个我们在aapt也是可以指定的(1-127即八位的合法空间,一些混合编译就是改这个packageID)。 —string, 代表stringblock，我们一共有三种类型的stringblock。分别是table stringblock,typename stringblock, specsname stringblock。 —type，这里讲的是typename stringblock里面我们用到的各种type(用到多少种类型的type,就有多少个type chunk)，例如attr, drawable, layout, id, color, anim等，Type ID是紧跟着Package ID。 —config, 即是Android用来描述资源维度，例如横竖屏，屏幕密度，语言等。对于每一种type，它定义了多少种config，它后面就紧跟着多少个config chunk,例如我们定义了drawable-mdpi,drawable-hdpi,那后面就会有两个config。 将Resource.arsc文件部分内容读出显示如下： 最后如果我们要在这里进行混淆的话，需要读取二进制文件resource.arsc，然后修改某一段一段的字节。例如有一段叫res/drawable/ic_launcher.png 在自己数组当中的第800-810位，我们只需要将这一段第800位-810位替换成改成r/d/a.png 的字节码即可 好了，发一下读取的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667ZipFile zipFile = new ZipFile(path);InputStream inputStream = zipFile.getInputStream(new ZipEntry(""+"resources.arsc"));LEDataInputStream leDataInputStream = new LEDataInputStream(inputStream);//Resource Table 头short type = leDataInputStream.readShort();leDataInputStream.skipBytes(2);leDataInputStream.readInt();int packageNum = leDataInputStream.readInt();System.out.println("num of package:"+packageNum);//StringPool块int got =leDataInputStream.readInt();//块大小int chunkSize = leDataInputStream.readInt();//字符串数量int stringCount = leDataInputStream.readInt();//style数量int styleCount = leDataInputStream.readInt();//标记int flags = leDataInputStream.readInt();//字符串起始位置int stringsOffset = leDataInputStream.readInt();//style起始位置int stylesOffset = leDataInputStream.readInt();int[] array = new int[stringCount];for (int i = 0; i &lt; stringCount; ++i)&#123; array[i] = leDataInputStream.readInt();&#125;if (styleCount != 0) &#123; for (int i = 0; i &lt; styleCount; ++i) array[i] = leDataInputStream.readInt();&#125;//字符串长度int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;byte[] m_strings = new byte[size];StringBuffer ss = new StringBuffer();leDataInputStream.readFully(m_strings);for(int i = 0;i&lt;m_strings.length;i++)&#123; //(通过打开resources.arsc看到一些乱码 猜得出字符都是ASCII码) char c = (char) m_strings[i]; ss.append(c);&#125;System.out.println(ss.toString());if (stylesOffset != 0) &#123; size = chunkSize - stylesOffset; if (size % 4 != 0) throw new IOException("Style data size is not multiple of 4 (" + size + ")."); for (int i = 0; i &lt; size / 4; ++i) leDataInputStream.readInt();&#125;//nextChunkleDataInputStream.readShort();leDataInputStream.skipBytes(2);leDataInputStream.readInt();int id = (byte) leDataInputStream.readInt();StringBuilder sb = new StringBuilder(16);int length = 256;while (length-- != 0) &#123; short ch = leDataInputStream.readShort(); if (ch == 0) break; sb.append((char)ch); &#125;System.out.println("pacakgeName:"+sb.toString()); zipalign优化我们知道APK其实就是一个Zip压缩文件，从原理上来讲就是通过格式化Zip文件夹中二进制文件的序列，达到提升系统解析速度。就像我们在阅读代码的过程中先格式化一遍代码，会让我们更容易理解其含义一样。在Android平台中，数据文件存储在apk文件中，可以多进程的访问，如果你开发过Win32可能知道程序的粒度对齐问题，不错虽然不是PE格式的文件，在Zip中一样，资源的访问可以通过更好的对其优化，而zipalign使用了4字节的边界对齐方式来影射内存，通过空间换时间的方式提高执行效率。 我理解的是：通俗的说就是按着有利于系统处理的排列方式，对我们apk中的资源文件进行排列，提高资源的查找速度，从而去提高应用的运行效率。先签名再对齐,否则先对齐再签名会破坏对齐使用1234567891011 release &#123; // 不显示Log buildConfigField "boolean", "LOG_DEBUG", "false" //混淆 minifyEnabled true //Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true ......&#125; 使用ReDex优化ReDex是Facebook开源一个减小安卓app大小以提高性能的工具，内嵌以及清除僵尸代码这样的优化来减小字节码，主要是对Dex进行了优化，能让APK 运行更快，不过需要多测试是否会崩溃。 经过 Redex 转换后的 APK，体积变得更小，运行速度变得更快。Redex 基于管道的方式来优化 Android 的 .dex 文件，一个源 .dex 文件通过管道进行一系列的自定义转换后，将得到一个优化的 .dex 文件。 我们知道 Android 的编译过程首先是通过 javac 工具将 .java 文件编译成 .class 文件，接着将所有的 .class 文件合并成 Dalvik 虚拟机的可执行文件 .dex，最后再跟其他资源等文件一起压缩成 APK 文件，大致流程如下所示： 转换的时机Redex 选择基于字节码文件而不是 Java 源码进行优化，是因为字节码相比 Java 源码而言，可以进行更为全局的，类与类之间的优化，而不是单个类文件的局部优化；选择基于 dex 字节码而不是 Java 字节码进行优化，是因为某些优化只能在 dex 文件中进行。 管道的思想鉴于随着时间的推移，开发人员可能会不断得到新的优化 idea，为了方便的将新的优化点加入既有的代码中，同时也方便不同开发人员并行开发优化点， 所以 Redex 选择基于管道的思想来实现 dex 的优化，这样每一个优化的 idea 可以通过插件的形式集成到管道中，实现即插即用，也不会影响其他的优化插件，整体优化流程如下所示：github地址：https://github.com/facebook/redex]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service进程防杀技术]]></title>
    <url>%2F2017%2F06%2F05%2F20170605_Service%E8%BF%9B%E7%A8%8B%E9%98%B2%E6%9D%80%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[前言]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化利器(图片压缩)]]></title>
    <url>%2F2017%2F06%2F04%2F20170604_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8(%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9)%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化利器(UI渲染篇)]]></title>
    <url>%2F2017%2F06%2F03%2F20170603_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8(UI%E6%B8%B2%E6%9F%93%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言本篇我们来学习如何在UI渲染的层面上对性能进行优化，其实就是结合hierarchyviewer工具对布局中嵌套层次、过度绘制等进行优化. CPU &amp; GPU介绍Android系统的渲染管线分为两个关键组件：CPU和GPU，它们共同工作，在屏幕绘制图片，每个组件都有自身定义的特定流程。我们必须遵守这些特定的操作规则才能达到效果。OK，来张图了解一下CPU和GPU的职责在CPU方面，最常见的性能问题就是不必要的布局，这些内容必须在视图层次结构中进行测量、清除并重新创建，引发这种问题通常有两个原因：1是重建显示列表次数太多 2是花费太多时间作废视图层次并进行不必要的重绘，这两个原因在更新显示列表或者其他缓存GPU资源时导致CPU工作过度 在GPU方面，最常见的问题是我们所说的过度绘制，通常实在像素着色过程中，通过其他工具进行后期着色时浪费了GPU处理时间 想要开发一款性能优越的应用，我们要了解底层是如何运行的。有一个主要的问题就是，Activity是如何绘制到屏幕上？哪些复杂的XML布局文件和标记语言，是如何转化成用户能看懂的图像的？实际上，这是由格栅化操作来完成的，格栅化就是将例如字符串、按钮、路径或者形状的一些高级对象，拆分到不同的像素上在屏幕上进行显示，格栅化是一个非常费时的操作。我们所有人的手机里面都有一块特殊硬件，它就是图像处理器（GPU显卡的处理器），目的就是加快格栅化的操作，GPU在上个世纪90年代被引入用来帮助加快格栅化操作。 60HZ是屏幕刷新理想的频率。60fps—一秒内绘制的帧数。24帧/秒 电源胶卷时代 在60fps内，系统会得到发送的VSYNC(垂直刷新)信号qu去进行渲染，就会正常地绘制。60fps要求：每一帧只能停留16ms. VSYNC(垂直刷新/绘制)：有两个概念 1）Refresh Rate：屏幕在一秒时间内刷新屏幕的次数—-有硬件的参数决定，比如60HZ. 2）Frame Rate：GPU在一秒内绘制操作的帧数，比如：60fps。 Hierarchyviewer工具的使用首先必然是如何去使用Hierarchyviewer去链接到模拟器或真机上，这里给出别人写不错的博客，可以按照步骤去安装就可以了。https://www.jianshu.com/p/afbf3444db19 GPU过度绘制问题进行优化目前流行的布局就是一把双刃剑，带给我们漂亮的视觉感受的同时，也造成过度绘制的问题，为了最大限度地提高应用程序的性能，我们必须减少过度绘制。常用的方法就是手机开发者自带的Show GPU overdraw。 对于GPU的优化我们有两个方案 1、去掉因为布局中、主题中的背景引起的过度绘制 2、在自定义View中通过clipRect裁剪来减少过度绘制 1、如果去掉主题的背景可使用getWindow().setBackgroundDrawable(null); 2、自定义View中的优化ok,先来看一下优化之前的效果 图与图的重叠区域发生了过度绘制的现象，对于自定义view的优化，这里我们使用了canvas.clipRect 1234567private void drawDroidCard(Canvas canvas,List&lt;DroidCard&gt; mDroidCards,int i) &#123; DroidCard c = mDroidCards.get(i); canvas.save(); canvas.clipRect((float)c.x,0f,(float)(mDroidCards.get(i+1).x),(float)c.height); canvas.drawBitmap(c.bitmap,c.x,0f,paint); canvas.restore();&#125; 是不是很6！！ CPU过度绘制问题进行优化CPU的优化要从减轻加工View对象成Polygons和Texture来下手，因为在我们的布局中包含了太多的没用的View，这些View根本就不会显示到屏幕上，一旦触发测量和布局操作就会拖累应用的性能表现。这时候就需要使用我们的View Hierarchy工具来找出没用的View、减少不必要View的嵌套 三个圆点分别代表：测量、布局、绘制三个阶段的性能表现。 1）绿色：渲染的管道阶段，这个视图的渲染速度快于至少一半的其他的视图。 2）黄色：渲染速度比较慢的50%。 3）红色：渲染速度非常慢。 优化思想:查看自己的布局，层次是否很深以及渲染比较耗时，然后想办法能否减少层级以及优化每一个View的渲染时间。 View Hierarchy工具使用比较简单，这里便不再多说。 未完，待续….]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化利器(内存抖动篇)]]></title>
    <url>%2F2017%2F06%2F02%2F20170602_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8(%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言TraceView这个工具是Android SDK中内置的一个工具，通过生成trace文件来展示代码的执行时间、次数便于我们分析。那TraceView的应用场景是什么呢？当我们面对手机运行app执行某个操作过于卡顿时候，我们要在无边际的代码找到罪魁祸首未免太痛苦了，就在这时候就体现了TraceView的强大。它主要解决下面两个场景：1、调用次数不多，但是每一次执行都很耗时2、方法耗时不大，但是调用次数太多前者可能会造成CPU频繁调用，手机发烫的问题，后者则就是卡顿的问题。为了确保应用程序的高性能，每项功能都应该尽可能高效地运行。 生成trace文件要使用TraceView工具就应该知道怎样去生成trace文件，在Android中生成trace文件的方法也挺多，有以下三个方法：1、使用代码2、使用Android Studio3、使用DDMS这三种的具体打开方法请看http://blog.csdn.net/u011240877/article/details/54347396 TraceView工具的使用这里我们只介绍使用DDMS的方式生成trace文件的情况，因为其他的情况有一些限制（需要root手机、不能直观查看执行时间）Ok，网上已经有很多关于 TraceView的使用，这里就不再重复造轮子http://blog.csdn.net/itfootball/article/details/48792435 实际应用对于这些操作信息都已经讲完了，接下来我们实际应用以下1234567891011121314151617181920212223public void imPrettySureSortingIsFree() &#123;//排序后打印二维数组，一行行打印 int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for(int i = 0; i &lt; lotsOfInts.length; i++) &#123; for (int j = 0; j &lt; lotsOfInts[i].length; j++) &#123; lotsOfInts[i][j] = randomGenerator.nextInt(); &#125; &#125; for(int i = 0; i &lt; lotsOfInts.length; i++) &#123; String rowAsStr = ""; //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) &#123; rowAsStr += sorted[j]; if(j &lt; (lotsOfInts[i].length - 1))&#123; rowAsStr += ", "; &#125; &#125; &#125;&#125; 看到上面的代码我们一眼就能看出来不能够使用字符串的加号而应该改为StringBuilder或者StringBuffer的append方法，例子比较简单主要我们还是学习如何去查找导致app卡顿的代码方法。在时间线面板上在main线程上找到相同颜色出现频率最多的一个小立柱，点击之后再分析面板就去会定位到该方法，然后分析Cpu执行该方法和其子方法所花费的时间以及调用次数+递归次数来查找当前方法是否是我们应用中发生内存卡顿的方法，当这个方法不是，但是我占时间或者次数较高则可以对其Parent或者Child进行查询,当然也有可能我们找不到相应的方法，但是可以从这里面的方法找到相应的蛛丝马迹ok,我们定位到了这个方法，这时候我们需不需要在查看parent呢？这时候也要看实际情况来决定，在上图中parent是onClick时间，很明显导致内存卡顿的是click调用的方法。当然找到相应的问题只是其中一步，更多的应该是怎么去发生卡顿的问题进行优化。 那我们在来看一个例子，使用斐波那契递归算法123456789public int computeFibonacci(int positionInFibSequence) &#123; //0 1 1 2 3 5 8 if (positionInFibSequence &lt;= 2) &#123; return 1; &#125; else &#123; return computeFibonacci(positionInFibSequence - 1) + computeFibonacci(positionInFibSequence - 2); &#125;&#125; 当递归的深度比较大时就会发生卡顿现象，这里我们令递归的深度为40来进行分析，按上面分析步骤找到出现颜色最多的一个小立柱，一步步就能找到相应的位置，这里就不再多说了，那既然知道了是斐波那契递归引起的卡顿现象，那怎么去优化呢?这里我们可以采用缓存+批处理的思想将递归变为循环遍历，具体步骤如下： 代码如下：1234567891011public int computeFibonacci(int positionInFibSequence) &#123; int prev = 0; int current = 1; int newValue; for (int i=1; i&lt;positionInFibSequence; i++) &#123; newValue = current + prev; prev = current; current = newValue; &#125; return current;&#125; 这里用到了批处理和缓存的技术，这里说一下这两个技术的概念：一些函数和运算，需要非常大的资源开销，这也会影响计算性能。例如，在执行之前把数据载入特定的内存区域，或者，在搜索之前对数值集进行排序，在执行多次之后，而且次数确实是个很大的数字，资源开销将会严重影响应用程序的性能。批处理是可以帮助解决这种性能问题，它消除每个运算的独立执行开销。这种情况最常见于在执行运算之前，你需要准备数据。例如，在查找集合中的值时，最有效的方法是进行排序，然后进行二分法搜索等等。有一点必须弄清楚，这并不是最有效的方法。这只是举一个例子而已，最简单的方法是写一个函数，提供一个集合和一个值，对集合进行排序，然后查看值是否存在于集合之中。对于某些性能要求来说，这样做是可以的。缓存是与批处理相似的概念，这也是目前为止，你能理解的最重要的性能技术。这项技术全面地推动现代计算机科学的发展，以计算机为例，内存的作用是用来存储信息，让CPU能够更快的访问数据，其速度远快于访问硬盘数据。 至此，对于TraceView的总结就结束了，因为工具的使用更多是在实践去摸索，所以使用一篇文章不足以体现TraceView工具的强大，当然工具永远都是用来使用的，真正的找到最好的优化策略才是重中之重 官方也给出了一些性能优化的知识，官网如下：https://developer.android.com/training/articles/perf-tips.html]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化利器(内存泄漏篇)]]></title>
    <url>%2F2017%2F06%2F01%2F20170601_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8(%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言程序开发是一个混乱又疯狂的过程，内存通常都没有办法完全被释放，这些被囚禁的内存叫做内存泄漏。 Android工程师花费大量时间降低干扰，确保这些程序以最快的速度运行，即便是这样当有许多的GC或一大串指令一个接着一个操作，帧像时间很可能会超过16毫秒的呈像障碍，这会导致隐形的碰撞或闪躲。就是这样，如果要减少任意帧内启动GC的次数，需要着重优化程序的内存使用量,从指令的角度很难追踪这些问题的起因，但是好在Android SDk 内置了不错的一些工具帮助开发者迅速定位发生内存泄漏的代码 java的四种引用 StrongReference强引用在程序代码中普遍存在，只要某对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OOM也不会回收这种对象 SoftReference软引用在java中使用SoftReference类来表示，对于软引用关联着的对象，只有内存不足的时候JVM才会回收该对象。因此这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存软引用可以和一个引用队列ReferenceQueue联合使用，如果软引用所引用的对象呗JVM回收，这个软引用就会被加入到与之关联的引用队列中 WeakReference弱引用在java中使用WeakReference类来表示，弱引用也是用来描述非必需对象，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象 PhantomReference虚引用虚引用和前面软引用、弱引用不同，它并不影响对象生命周期。在java中用PhantomReference类表示，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否真已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 判断一个应用内存泄漏避免得很好当App退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄漏的(View、Activity)是否还在内存中，可以让app退出以后查看系统该进程里面的所有的View、Activity对象是否为0。工具使用AndroidStudio-&gt;Android Monitor-&gt;System Information-&gt;Memory Usage看Objects里面的views和Activity的数量是否为0。 Heap Snapshot的使用在使用工具之前我们需要知道这个工具是来做什么用的？Heap SnapShot是用来获取Java堆内存详细信息通过分析可以验证自己的一些猜想，为什么是验证自己猜想呢？因为我们在实际项目中会通过Android Monitor工具来查看某个操作是否存在内存泄漏。例如：最直观的是查看内存增长情况，知道该动作是否发生内存泄漏，动作发生之前：GC完后内存1.4M；动作发生之后：GC完后内存1.6M对于Heap SnapShot的使用网上已经有了明确的介绍，这里我便不在重复造轮子了http://blog.csdn.net/itfootball/article/details/48786275 发一下我们测试的代码，很简单，就是静态对象持有Ativity的对象123456789101112131415public class CommUtil &#123; private static CommUtil instance; private Context context; private CommUtil(Context context)&#123; this.context = context; &#125; public static CommUtil getInstance(Context context)&#123; if(instance == null)&#123; instance = new CommUtil(context); &#125; return instance; &#125;&#125; 我们不断的去横竖屏切换，当然我们已经知道了结果（内存中至少会有2个MainActivity的实例），通过Heap SnapShot工具就可以验证在内存中确实会持有至少2个MainActivity对象，最后就是对这段代码进行改进就可以了（将Context改成ApplicationContext）。在我们实际开发中也会通过去猜测哪些类可能发生内存泄漏然后通过Heap SnapShot去验证 MAT的使用可能是我的技术有限，个人觉得MAT工具基本上和heap SnapShot差不多，MAT突出的优势就是我们可以通过和频繁执行一个操作的Prof进行比较通过Total Size的值是否越来越大来初步判断这个操作导致了内存泄漏。 如果发生了内存泄漏也可以通过这个工具判断出具体是哪些对象（通过定位操作前后所持有的对象增加了），技巧：使用Histogram中对对象Group，例如选择Group By Package更方便查看自己Package中的对象信息 Ok，MAT的工具在网上已经有了明确介绍，这里我也不再重复造轮子http://blog.csdn.net/itfootball/article/details/48834711 既然通过MAT工具查找出了哪些对象可能发生内存泄漏，接下来我们就需要对这些对象逐个进行排查。步骤：(1)进入Histogram，过滤出某一个嫌疑对象类(2)然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects—&gt;with incoming references）(3)再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露(在类上面点击右键Merge Shortest Paths to GC Roots—&gt;exclude all phantom/weak/soft etc.references)(4)进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！ Heap Viewer的使用这个工具只能判断是否有内存的泄漏操作起来比较方便，我们需要注意的就是Heap Viewer的使用条件(1)5.0以上的系统，包括5.0(2)开发者选项可用具体工具的使用，网上已经有很多文章，这里就不再重复的造轮子了http://blog.csdn.net/itfootball/article/details/48734553 具体实际的应用MainActivity.java12MyView myView = new MyView(this);setContentView(myView); ListenerCollector.java12345678public class ListenerCollector &#123; static private WeakHashMap&lt;View,MyView.MyListener&gt; sListener = new WeakHashMap&lt;&gt;(); public void setsListener(View view, MyView.MyListener listener)&#123; sListener.put(view,listener);&#125; public static void clearListeners()&#123; //移除所有监听。 sListener.clear(); &#125;&#125; MyView.java1234567891011121314151617181920public class MyView extends View&#123; public MyView(Context context)&#123; super(context); init(); &#125; public interface MyListener&#123; public void myListenerCallback(); &#125; private void init()&#123; ListenerCollector collector = new ListenerCollector(); collector.setsListener(this,myListener); &#125; private MyListener myListener = new MyListener() &#123; @Override public void myListenerCallback() &#123; System.out.print("有被调用"); &#125; &#125;;&#125; ok,不停的去旋转屏幕，如果不再onStop中移除掉上一次的监听，就会在HashMap集合中不停的去添加监听对象，这样使用Heap Viewer工具就会发现data object-&gt;Total Size会不断的增加，于是就可以得出该操作发生了内存泄漏，具体的定位将会使用上面的工具 Allocation Tracker的使用Ok，Allocation Tracker的工具在网上已经有了明确介绍，这里我也不再重复造轮子http://blog.csdn.net/itfootball/article/details/48750849 LeakCanary的使用Ok，LeakCanary的工具在网上已经有了明确介绍，这里我也不再重复造轮子http://blog.csdn.net/itfootball/article/details/49361401 引起内存泄漏的情况内存泄露(Memory Leak):进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.内存溢出(OOM):当应用占用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出。比如：加载大图片。 1、静态变量引起的内存泄露当调用getInstance时，如果传入的context是Activity的context。只要这个单例没有被释放，那么这个Activity也不会被释放，直到进程退出才会被释放 123456789101112public class CommUtil &#123; private static CommUtil instance; private Context context; private CommUtil(Context context)&#123; this.context = context; &#125; public static CommUtil getInstance(Context mcontext)&#123; if(instance == null)&#123; instance = new CommUtil(mcontext); &#125; return instance; &#125; 2、非静态内部类引起内存泄露(包括匿名内部类)错误的示范123456789public void loadData()&#123;//隐士持有MainActivity实例 new Thread(new Runnable() &#123; @Override public void run() &#123; int b=a; Thread.sleep(1000); &#125; &#125;).start();&#125; 解决方案：loadData方法修改为静态方法除了上面的写法，在实际的开发中会用到Handler，我们需要自定义Handler并设置为static，但是大多数我们需要在里面使用MainActivity的引用，那该怎么办呢？这时候我们可以定义MainActivity的软引用/弱引用，然后再handleMessage里面判断如果activity为空或者finish了则不向下执行。这样就避免了handle一直持有activity引用导致的内存泄漏 3、不需要用的监听未移除会发生内存泄漏123SensorManager sensorManager = getSystemService(SENSOR_SERVICE);Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST); 所以在onDestroy方法里面移除监听sensorManager.unregisterListener(listener); 4、资源未关闭引起的内存泄漏情况例如：BroadcastReceiver、Cursor、Bitmap、IO流、自定义属性等，要记得不使用的时候及时释放资源避免内存泄漏 5、无限循环动画当使用动画的时候没有在onDestroy里面停止动画导致内存泄漏]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin_mvp_dagger2_retrofit]]></title>
    <url>%2F2016%2F11%2F01%2F20170704_Kotlin%E5%AE%9E%E6%88%98(dagger2%2Bretrofit)%2F</url>
    <content type="text"><![CDATA[上一篇我们学习了anko库的使用，到这里我们来做一个简单的小项目吧！那使用什么架构来写呢，这里我们使用Kotlin+dagger2+retrofit+MVP架构来撸码 在学习这篇文章之前需要掌握下面的知识，如下： dagger2 http://www.jianshu.com/p/39d1df6c877d retrofit http://www.jianshu.com/p/308f3c54abdd API http://gank.io/api 正文因为项目中用的Dagger2比较多，这里来讲解一下项目中用到的几个注解，更多的详情可以看上面的地址 Component:组件、管理器、注入器功能就是将类中使用@Inject标记的属性和在对应属性类中使用@Inject标记的构造方法，然后将它们关联起来。 而如果构造方法需要参数，或者我们没法再需要注入的对象的构造方法加入@Inject注解的时候就需要使用Module 该注解里面的参数有两个，一个是设置modules所关联的Module类，第二个是dependency所依赖的Component Module：提供者、依赖对象工厂功能是与被@Inject标记的构造方法一样提供生成依赖的对象 因为对于第三方库我们没有办法将它的构造方法加入@Inject标记，这时候我们需要使用Module生成，并提供@provide注解，Component会去查找Module类中@provide的方法获取到对象并通过component返回目标类需要的对象并注入到目标类 Qualifier:限定符功能是在同一纬度下存在多个依赖对象的提供方式(多个构造方法)，则会迷失。这时，可以使用Qualifier 提供依赖对象有两种方式 （1）通过使用Inject注解标注的构造函数来创建 （2）通过工厂模式的Module来创建 如果一个依赖对象以上两种方式都能够提供，它会优先使用Module。Qualifier有一个@Named 指定相同的参数和自定义Qualifier注解一样的效果12345678@Qualifier@Documented@Retention(RUNTIME)public @interface Named &#123; /** The name. */ String value() default "";&#125; Scope:作用域 管理创建的类实例的生命周期。 可以通过Scope来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。 Scope本身没有制定生命周期的能力，它的存在一是为了可读性,二是更好的管理Component和Module的关系 如果你想了解Dagger2具体调用的流程可以查看 接下来我们开始看一下要做的小项目的效果图 ok,项目比较low，废话不多说，开始我们撸代码时间 我是这样分包的 在项目中我定义了一个全局的Component类12345678@Singleton@Component(modules = arrayOf(DataSourceModule::class)) //注入器对象提供工厂interface AppComponent&#123; /** * 全局注入器能够提供的对象 */ fun dataManager(): DataManager&#125; 这个类为DataSourceModule用来提供DataManager对象的生成，使用DataManager来对网络请求会去查询DataSourceModule类中去找生成DataManager对象的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Module class DataSourceModule &#123; @Singleton @Provides fun provideGankService(): GankService &#123; return Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL).build().create(GankService::class.java) &#125; @Singleton @Local @Provides fun provideLocal(): IDataSource&#123; return LocalDataSource() &#125; @Singleton @Remote @Provides fun provideRemote(service: GankService): IDataSource &#123; return RemoteDataSource(service) &#125; @Singleton @Provides fun provideDataManager(@Remote remote: IDataSource, @Local local: IDataSource): DataManager &#123; return DataManager(remote,local) &#125; &#125;```java这里推荐使用provide开头，在方法参数里面我有定义两个注解Remote和Local用来区分对应哪个一个IDataSource @Qualifier annotation class RemoteprovideGankService方法里面的写法使用了Gson转换用于将json转化为对象、Rxjava回调用来对网络请求的结果做不同的处理然后我们在来看一下DataManager类```java fun getWelfareList(page: Int): Flowable&lt;WelfareEntity&gt; &#123; return remote.getWelfareList(page).onErrorResumeNext(local.getWelfareList(page)) &#125; 主要是定义相应的规则，先在网络请求获取，当失败的时候获取本地的数据 ok,前期的工作准备完毕，为了更好去使用APPComponent，我们在Application自定一个单例12345678910111213141516171819202122class MyApplication: Application()&#123; /** * 提供全局注入器的获得 */ lateinit private var appComponent: AppComponent companion object &#123; lateinit var app: MyApplication fun getApplication(): MyApplication&#123; return app &#125; &#125; override fun onCreate() &#123; super.onCreate() app = this appComponent = DaggerAppComponent.builder().dataSourceModule(DataSourceModule()).build() &#125; fun getAppComponent(): AppComponent = appComponent&#125; 开始我们的主界面，当然这个项目也就一个Activity，既然是MVP就少不了Persenter @Inject lateinit var presenter: MainPersenter 使用Inject注解来自动去创建MainPersenter对象，然后定义MainAppComponent12345@ActivityScope@Component(modules = arrayOf(MainActivityModule::class),dependencies = arrayOf(AppComponent::class))interface MainAppComponent&#123; fun inject(activity: MainActivity)&#125; 这里对APPComponent进行了依赖，因为在MainPersenter类里面使用到了DataManager的对象12345678910@Moduleclass MainActivityModule(val view: MainActivity)&#123; @ActivityScope @Provides fun provide1Presenter(dataManager: DataManager): MainPersenter&#123; return MainPersenter(view,dataManager) &#125;&#125; 然后我们在来看一下MainPersenter12345678910111213class MainPersenter(val view: MainViews, val dataManager: DataManager) &#123; //福利 fun getWelfarmList(page: Int) &#123; dataManager.getWelfareList(page) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe &#123; view.startLoading() &#125; .doOnError &#123; view.stopLoading() &#125; .subscribe &#123; view.stopLoading() view.showWefareList(it.results) &#125; &#125; 在这个类中主要是使用DataManager的对象用来获取数据并针对获取成功和失败调用View层的方法 最后我们需要初始化Dagger2注入器12345//初始化Dagger2注入器 DaggerMainAppComponent.builder() .appComponent(MyApplication.getApplication().getAppComponent()) .mainActivityModule(MainActivityModule(this)) .build().inject(this) 另外在写生成ItemView的时候写了两种方式，这里也一并贴出来和大家一起分享 第一种使用with表达式123456789101112131415161718 val view = with(context)&#123; verticalLayout &#123; gravity = Gravity.CENTER_HORIZONTAL imageView &#123; id = R.id.welfare_item_iv imageResource = R.mipmap.ic_launcher scaleType = ImageView.ScaleType.FIT_XY lparams &#123; height = dip(250) width = matchParent leftMargin = dip(20) rightMargin = dip(20) topMargin = dip(15) bottomMargin = dip(15) &#125; &#125; &#125;&#125; 当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果12345678910111213141516171819202122232425262728293031323334class RecyclerUI: AnkoComponent&lt;AndroidAdapter&gt;&#123; override fun createView(ui: AnkoContext&lt;AndroidAdapter&gt;): View = with(ui)&#123; verticalLayout &#123; orientation = LinearLayout.HORIZONTAL lparams &#123; topMargin = dip(10) leftMargin = dip(15) rightMargin = dip(15) bottomMargin = dip(10) &#125; imageView &#123; id = R.id.android_item_iv imageResource = R.mipmap.android_icon lparams &#123; width = dip(90) height = dip(90) &#125; &#125; verticalLayout &#123; textView &#123; id = R.id.android_item_tv1 textSize = 18.toFloat() &#125; textView &#123; id = R.id.android_item_tv2 textSize = 16.toFloat() textColor = Color.RED &#125; &#125; &#125; &#125;&#125; 至此，小项目的讲解就结束了。 坚持总会有结果，总会有收获的]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI绘制_Paint高级渲染]]></title>
    <url>%2F2016%2F11%2F01%2F20180211_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[UML建模 Bitmap bitmap = BitmapFatory.deresources(res,id); 场景：创建对象简单工厂：提供创建对象的功能，不需要关心具体的实现 好处：降低客户端与模块之间的耦合度（最少知识原则） 需求：导出数据文件：数据库文件、文本文件 工厂方法：把对象的实现延迟到子类完成]]></content>
      <categories>
        <category>UI绘制</category>
      </categories>
      <tags>
        <tag>UI绘制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI绘制_Paint高级渲染]]></title>
    <url>%2F2016%2F11%2F01%2FUI%E7%BB%98%E5%88%B6_Paint%E9%AB%98%E7%BA%A7%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[上一篇讲解了Paint的基本使用，从初始化到绘制，学好了基本功接下来要开始Paint的高级渲染的部分在开始之前还是要留一下Paint的基本使用的地址 Paint的基本使用 http://www.jianshu.com/p/88d718d1945e 开始撸码~ 正文先来看一下要搞的效果图 ok,在Android中提供了如下的渲染类 BitmapShader /** * TileMode.CLAMP 拉伸最后一个像素去铺满剩下的地方 * TileMode.MIRROR 通过镜像翻转铺满剩下的地方。 * TileMode.REPEAT 重复图片平铺整个画面（电脑设置壁纸） */ BitmapShader bitMapShader = new BitmapShader(mBitMap,Shader.TileMode.MIRROR,Shader.TileMode.MIRROR); LinearGradient /**线性渐变 * x0, y0, 起始点 * x1, y1, 结束点 * int[] mColors, 中间依次要出现的几个颜色 * float[] positions,数组大小跟colors数组一样大，中间依次摆放的几个颜色分别放置在那个位置上(参考比例从左往右) * tile */ LinearGradient linearGradient = new LinearGradient( 0, 0,800, 800, mColors, null, Shader.TileMode.CLAMP); RadialGradient RadialGradient mRadialGradient = new RadialGradient(300, 300, 100, mColors, null, Shader.TileMode.REPEAT); SweepGradient SweepGradient mSweepGradient = new SweepGradient(300, 300, mColors, null); ComposeShader ComposeShader mComposeShader = new ComposeShader(linearGradient, bitMapShader, PorterDuff.Mode.DST_IN); 使用起来非常的简单，首先我们就使用composeShader来实现第二张图的效果 //图像渲染 BitmapShader bitmapShader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); LinearGradient linearGradient = new LinearGradient(0, 0, width, height, Color.GREEN, Color.BLUE, Shader.TileMode.REPEAT); RadialGradient radialGradient = new RadialGradient(width / 2, height / 2, width / 2, new int[]{0xffff0000, 0xff00ff00, 0xff0000ff}, null, Shader.TileMode.CLAMP); SweepGradient sweepGradient = new SweepGradient(width / 2, height / 2, new int[]{0xffff0000, 0xff00ff00, 0xff0000ff}, null); //将图像渲染和环形渐变进行组合，组合的形式是增强 ComposeShader composeShader = new ComposeShader(bitmapShader, radialGradient, PorterDuff.Mode.MULTIPLY); mPaint.setShader(composeShader); //绘制矩形区域用于显示组合之后的效果 canvas.drawRect(0, 0, width, height, mPaint); 然后我们使用BitmapShader来实现放大镜的效果 得到放大后图片 //放大后的整个图片 Bitmap scaleBitmap = Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth() * factor, mBitmap.getHeight() * factor, true); bitmapShader = new BitmapShader(scaleBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); 设置圆形的放大镜并将BitmapShader设置给放大镜Drawable mShapeDrawable = new ShapeDrawable(new OvalShape()); mShapeDrawable.getPaint().setShader(bitmapShader); mShapeDrawable.setBounds(0, 0, RADIUS * 2, RADIUS * 2); matrix = new Matrix(); 随着手指滑动，放大镜不断移动位置 //将放大镜的图片往相反的方向挪动 matrix.setTranslate(-x * factor + RADIUS, -y * factor + RADIUS); mShapeDrawable.getPaint().getShader().setLocalMatrix(matrix); //切出手势区域的位置的圆 mShapeDrawable.setBounds(x - RADIUS, y - RADIUS, x + RADIUS, y + RADIUS); invalidate(); 使用Android的渲染还能做好多的炫酷的效果，这里就不一一进行说明。]]></content>
      <categories>
        <category>UI绘制</category>
      </categories>
      <tags>
        <tag>UI绘制</tag>
      </tags>
  </entry>
</search>
