<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin基础第一弹]]></title>
    <url>%2F2016%2F06%2F01%2FKotlin_%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些&gt; 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##Kotlin集合集合无非是list集合和map集合，如下： val list = listOf(1, 2, 3, 4) val map = mapOf(1 to &quot;a&quot;, 2 to &quot;b&quot;, 3 to &quot;c&quot;) 是不是很简单，但它只能去遍历不能去操作，why?首先我们以list为例，点进去看一下它里面只有get、indexof、iterator方法，这也就决定了它的职责就是去遍历 那如果想进度读写操作,就需要去使用mutableListOf、mutableMapOf来创建集合了 既然我们创建了一个集合，我们就需要对于进行遍历，和java不同的是kotlin使用了in来遍历 for(i in list){ println(&quot;i=$i&quot;) } 也可以使用forEach list.forEach { println(&quot;it=$it&quot;) } 还有 list.forEachIndexed{ index,i-&gt; println(&quot;index=$index i=$i&quot;) } 等等。这时候我们可能会有疑问，forEach里面大括号里要写什么呢？其实它里面接受的是一个lamada表达式 @kotlin.internal.HidesMembers public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element) } 这里就需要说一下了，(T)-&gt;Unit表示接受一个T类型参数返回一个Unit类型的函数，Unit也就是java中void类型，我们在调用的时候需要传入{params-&gt;}这种式子，Kotlin规定当参数只有一个的时候可以不用写，默认是it,所以我们也可以这样写 list.forEach {item-&gt; println(&quot;item=$item&quot;) } 好了，list说完了，下面说说Map，我们在定义map的时候用到了to,其实是key to value的格式，to充当的是中缀表达式，我们也可以定义自己的中缀表达式 infix fun &lt;A,B&gt; A.with(that: B):Pair&lt;A,B&gt; = Pair(this,that) 这样我们就可以这样 val pair = 4 to &quot;d&quot; val (key,value) = pair; ok,集合就先到这里，更多操作可以实际去操作 ##Kotlin扩展函数 扩展属性扩展函数、扩展属性很简单，直接上例子 val String.lastChar: Char get() = get(length - 1) inline fun String.show(): Unit { println(&quot;String.show()&quot;) } 直接使用类名.方法即可，调用的时候就可以”lypop”.show() ##Kotlin函数kotlin函数有个特点就是可以设置默认值 fun test(a: Int = 1, str: String = &quot;&quot;) { print(&quot;test(a: Int = 1, str: String = \&quot;\&quot;)&quot;) } fun test(str: String = &quot;&quot;) { print(&quot;test(str: String = \&quot;\&quot;)&quot;) } fun test(a: Int = 1, b: Int = 2, str: String = &quot;&quot;) { print(&quot;test(a: Int = 1, b: Int = 2,str: String = \&quot;\&quot;)&quot;) } 当你调用test()会执行最匹配的方法fun test(str: String = “”)，在kotlin也有java的可变参数，只需要在方法写入vararg item: Int即可 ##Kotlin可为空这个比较简单，先上代码 val str: String? = null str?.length 下面的调用也可以使用str!!.length的样式，具体？的使用在之后会经常用到，多多体会就好，这里不做过多的赘述 ##Kotlin字符串的使用字符串的操作这里以分割来说一下 val str = &quot;com.lypop.android&quot; val list = str.split(&quot;.&quot;) if(list is List){ for(value in list){ println(&quot;value=$value&quot;) } } 就是这么简单的一些调用，当然还有一些其他复杂的操作，例如 val path = &quot;E:\\md_workspace\\Kotlin_collection.md&quot; val afterLast = path.substringAfterLast(&quot;.&quot;) //获取到md println(&quot;afterLast=$afterLast&quot;) val beforeLast = path.substringBeforeLast(&quot;:&quot;) println(&quot;beforeLast=$beforeLast&quot;) val missingValue = path.substringBeforeLast(&quot;?&quot;,&quot;missing value&quot;) //如果没有找到的话则返回第二个参数 println(&quot;missing Value=$missingValue&quot;) 是不是相比java的substring更加灵活了，当然对于这种字符串的操作会使用就可以了，当然不知道意思的话，可以进源码查看也可以百度最后在说两个比较常用的知识点 打印&amp;字符 println(&quot;\$abc&quot;) println(&quot;&quot;&quot; ${&apos;$&apos;}abc &quot;&quot;&quot;) 使用正则表达式 val match = &quot;(.+)\\.(.+)\\.(.+)&quot;.toRegex() val matchResult = match.matchEntire(&quot;com.lypop.one&quot;) val list1:List&lt;String&gt;? = matchResult?.destructured?.toList() if(list1 != null){ for(str in list1){ println(&quot;str=$str&quot;) } } 至此，简单的Kotlin第一段就结束了，相对于java来讲使用起来更加的方便更加高效，快来试试吧！]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础第三弹]]></title>
    <url>%2F2016%2F06%2F01%2FKotlin_%E7%AC%AC%E4%B8%89%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##Start ####kotlin委托机制委托模式也是代理模式是软件设计模式中的一项基本技巧，在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理 在java和Android用到委托机制在AOP里，在java中使用继承InvocationHandler接口的方法来实现代理，而在Android中则使用AspectJ的方式来实现。在这里我们来讲解一下Kotlin的委托模式 类委托也就是上面讲的委托模式定义，然而在Kotlin中实现起来更加的方便更加的灵活，如： class MyList(list: ArrayList&lt;String&gt;) : Collection&lt;String&gt; by list { } 这种也是替代继承的方式，直接使用by关键字就将Collection的方法委托给list对象 属性委托在Kotlin中Delegates类内置了三种委托的方法，分别是lazy、notNull()、observable(“”)、vetoable(“”)、Map形式 lazy 用于进行懒加载，即第一次使用的时候才执行初始化操作 //当使用的时候才进行初始化（线程安全的） val list: ArrayList&lt;String&gt; by lazy { ArrayList&lt;String&gt;() } notNull() 使用于那些无法再初始化阶段就确定属性值的场合 //初始化str,用于为空属性进行初始化的场景 var str: String by Delegates.notNull&lt;String&gt;() observable() 观察者和java的观察者模式差不多 //oldValue是变化之前的值 newValue最新的值 var str: String by Delegates.observable(&quot;&quot;){//初始值 property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) } vetoable（）带条件的委托机制，通过返回的true和false来确定oldValue是上一个还是最初的 //返回true和observable是一样的效果 var str1: String by Delegates.vetoable(&quot;&quot;){ property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) true } //返回false则标志oldValue永远为初始值 var str2: String by Delegates.vetoable(&quot;&quot;){ property, oldValue, newValue -&gt; println(&quot;${property.name} old=$oldValue new=$newValue&quot;) false } Map 通过一种全新的赋值方法给类属性进行赋值 class User(val map: Map&lt;String,Any?&gt;){ val name: String by map val age: Int by map } val user = User(mapOf(&quot;a&quot; to 1)) 除此之外我们也可以自定义委托，具体定义可仿照notNull()委托 private class NotNullVar&lt;T: Any&gt;() : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return value ?: throw IllegalStateException(&quot;Property ${property.name} should be initialized before get.&quot;) } public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { this.value = value } } 你也可以设置可读的委托机制，继承ReadOnlyProperty类即可 ####kotlin lambda表达式首先先给出一个小例子 val action = {i: Int, j: Int -&gt; println(&quot;i=$i j=$j&quot;)}; action(1,2) 注意的是lambda表达式用{}包裹，箭头前面是参数的参数，箭头后面是函数体；从调用上来说比java简单并且优雅了许多，但是实际用途呢？我们可以为一个函数传一个lambda，如： fun lambdaTest(arg1: Int, arg2: Int, oper: (a: Int, b: Int) -&gt; Int): Int { var result: Int = Int.MIN_VALUE if (arg2 != 0) { result = oper(arg1, arg2) } return result } fun main(args: Array&lt;String&gt;) { lambdaTest(1, 2, { a: Int, b: Int -&gt; a / b }) 既然是传函数当然也可以传递一个函数进去，常使用::，这里延伸出函数的引用，另外还有属性的引用，这里 listOf(1, 2, 3).forEach(::println) var name = &quot;1&quot; val p = ::name p.set/get 当最后一个参数为lambda的时候，可以将大括号放在外面，如： lambdaTest(1, 2){ a: Int, b: Int -&gt; a / b } 用lambda表达式的情况还是挺多的，例如在集合中遍历等操作 val list = arrayListOf(1, 2, 3) list.forEach { value -&gt; } ####kotlin 运算符重载表达式 class Rmb(var num: Int) { operator fun plus(rmb: Any?) { } } 这样就可以使用Rmb(1) + Rmb(2)进行计算了，是不是很简单。这种操作和前面讲的中缀表达式一样，只不过中间的是运算符了而已 ####kotlin 注解与反射 Kotlin的注解和java是类似的，先确定注解的类型，然后确定生命周期 @Target(AnnotationTarget.FIELD, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION) @Retention(AnnotationRetention.SOURCE) annotation class Path 使用的话直接在class前 fun前面 @Path class UsePath(val p: String) { } Kotlin反射则通过 String::class.java String.javaClass 这两种方式来得到Class&lt;?&gt;对象，进一步可反射得到相应的属性和方法]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础第二弹]]></title>
    <url>%2F2016%2F06%2F01%2FKotlin_%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，由于是Google推荐使用的，可见其重要性，当你真正深入的时候也会发现kotlin的优雅，让你在写代码的时候省时又省力 对于Kotlin的学习网上有好多，现在分享一些 官方网址 http://kotlinlang.org/docs/reference/ 别人的总结 https://github.com/youxin11544/Kotlin-learning 在这里不会像官网那样一一的去讲解，自己也是从官网去学习然后去看别人的博客，对于知识而言可能并不深入，但对于初学者而言也值的一看 ##kotlin类对于类，我们先要说下在Kotlin中接口有啥特点 interface OnClickListener{ val name: String fun test(){ println(&quot;OnClickListener test&quot;) } fun action() } 和java的接口相比，kotlin的接口更加强大还可以写方法的实现，还有一个那就是接口open类型的可以被直接继承 class Child1 : OnClickListener,OnClickListener1{ override val name: String = &quot;&quot; override fun test() { super&lt;OnClickListener&gt;.test() } override fun action() { } override fun action1() { } } 当你需要在子类方法调用父类的方法的时候直接super即可 对于抽象类 abstract class ABParent{ abstract fun test() } class ABChild: ABParent(){ override fun test() { } } 也是直接可以继承的，里面的abstract方法默认是open修饰 对于普通类就需要给父类用open进行修饰才能进行继承，因为对于类来说默认是final类型的，接下来我们就需要对类进行一些研究，对于java类分为内部类、外部类、静态类等等，kotlin当然也会有区分 class ClassA{ var name: String = &quot;lypop&quot; class NestClass{ fun test(){ //name = &quot;&quot; 嵌套类不能访问外部类的属性和方法 } } //内部类 存在外部类的引用 可以访问外部类的属性和方法 inner class InnerClass{ fun test(){ name = &quot;change Name&quot; } } //创建伴生对象 companion object { var comName = &quot;aaa&quot; fun companionTest(){ println(&quot;companionTest&quot;) } } //定义静态内部类 object InnerStaticClass{ fun test(){ comName = &quot;===&quot; } } } //定义静态外部类 object StaticOuterClass{ val age: Int = 22 } 这里我们需要注意： 嵌套类不能访问外部类的属性和方法,内部类才可以访问 因为kotlin没有static关键字，如果要在类中定义静态的方法和属性需要来创建伴生对象，在使用的时候可以ClassA.companion.comName也可以直接ClassA.comName访问 静态内部类可以访问伴生对象的属性和方法，就和java中静态内部类可以访问外部类定义的静态属性和静态方法是一样的 接下来一个便是匿名内部类的写法 val obj = object: OnClickListener2{ override fun test() { println(&quot;object test()&quot;) } } 该内部类实现了OnClickListener2的接口，将对象赋值给了obj 最后也就是Kotlin的数据类，和java中的Bean类一样，只有类属性和相应的get/set方法 data class Person(val name: String) ##kotlin类构造方法类的构造方法和java有些不同，kotlin分为主构造方法和次构造方法 class User(name: String) {//主构造方法 var name: String = &quot;&quot; var pwd: String = &quot;&quot; //次构造器 constructor(name: String, pwd: String) : this(name) { this.name = name this.pwd = pwd } //初始化器 init { this.name = name } } 这里需要注意的是： 次构造方法必须要去初始化主构造方法 当主构造方法需要权限等修饰的时候constructor必须要加上，其他的情况可以不写 对于初始化字段可以放在init初始化器中进行初始化 至此，Kotlin的第二讲完了，每天的坚持，总有一天会获得收获。 ~ 共勉]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础第四弹]]></title>
    <url>%2F2016%2F06%2F01%2FKotlin_%E7%AC%AC%E5%9B%9B%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Kotlin我们也学了一些基础，但怎么用我们还是不知道？今天我们从基础转向实战，在Android平台上开发Kotlin 因为这篇我们会讲到anko的知识下面贴出它的官网地址，感兴趣的可以单独去研究 https://github.com/Kotlin/anko/wiki ##调用第三方库使用Kotlin这里我们以ButterKnife为例，配置ButterKnife在Kotlin的环境 首先加入kotlin的classpath ext.kotlin_version = &apos;1.1.2-3&apos; repositories { jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.1&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; } 然后添加kotlin依赖 apply plugin: &apos;kotlin-android&apos; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; 最后加入ButterKnife依赖，这里需要注意的是另外也添加kapt插件 apply plugin: &apos;kotlin-kapt&apos; compile &apos;com.jakewharton:butterknife:8.6.0&apos; kapt &apos;com.jakewharton:butterknife-compiler:8.6.0&apos; 这样kapt会将ButterKnife的java代码转化为kotlin代码 至此环境就配置好了，当然你也可以在网上搜一搜，这里也就是做个笔记 ##使用anko库 ###Anko Dialog对于Anko的Dialog用的最多的也Toast的使用，在Anko中使用toast是相当的简单 fun open_toast(view: View){ toast(&quot;toast&quot;) longToast(&quot;long toast&quot;) } 然后就是AlertDialog的使用也是一看就会用的那种 fun open_alert(view: View){ alert(&quot;Hi,I&apos;m Roy&quot;,&quot;Have you tried turning it off and on again?&quot;){ yesButton { toast(&quot;yes&quot;) } noButton { toast(&quot;no&quot;) } }.show() //当然你也可以使用自定义的View alert{ customView{ editText() } } } 当然还有其它的弹框这里就不一一介绍，具体请看官方 ###Anko Intent相比之前的Intent来说Anko提供的更加的方便，使用如下 startActivity(intentFor&lt;AnkoActivity01&gt;(&quot;id&quot; to 5).singleTop()) 其他的一些使用如下： ###Anko Log对于Log，Anko解释AndroidSDK提供的Log也是非常的简单，尽管方法需要你传递标签参数，但使用起来也是非常的简单，当然你也可以使用AnkoLogger来消除这一点 实现AnkoLogger的方式 info(&quot;this is second log info&quot;) //这种带lambda表达式的这种会去计算Log.isLoggable(tag, Log.INFO)是否为true，为true的话才打印 info { &quot;this is third log info&quot; } 使用其对象的方式 val logWithASpecificTag = AnkoLogger(&quot;lypop&quot;) logWithASpecificTag.info { &quot;this is Log info&quot; } 第一种Tag默认是类名，第二种可以自定义其Tag ###Anko helper你可以在你的项目中使用帮助者来简化你的代码，例如Color、Dimen等，颜色透明度直接色值.opaque就可以，尺寸的话直接使用dip(dipValue)、sp(spValue)就可以。在这里面还有一个就是applyRecursively()用来控制子View的操作，如： verticalLayout { textView{ text = &quot;EditText01&quot; backgroundColor = 0xff000.opaque textSize = 14f } textView { text = &quot;EditText02&quot; backgroundColor = 0x99.gray.opaque textSize = 23f } }.applyRecursively {//如果是ViewGroup的话可以使用applyRecursively来为每个Child View进行设置 view -&gt; when(view){ is TextView -&gt; view.textColor = Color.RED } } ###Anko CoroutinesAnko还提供了协程的用来做一些耗时的操作，提供的操作为bg{},具体代码如下： async(UI){//UI线程 val data: Deferred&lt;MyBean&gt; = bg {//后台线程 // Runs in background MyBean() } showData(data.await()) //await方法将一直等待bg返回的数据 } 为了防止内存泄漏我们常会使用弱引用，在Anko中使用弱引用方法如下： val ref: Ref&lt;AnkoActivity05&gt; = this.asReference() async(UI){ //ref替代了this@AnkoActivity05 ref().showData() } ###Anko Layout那我们先来说一下普通写Android布局有啥缺点 它不是类型安全的和不是空安全 它迫使您为每个布局都编写相同的代码 在设备上解析xml浪费CPU时间和电池 最重要的是它不允许代码重用 那Kotlin不行吗?为什么还要用anko呢？ 官方解释说Kotlin那种是解决了不能编程生成UI，但是用Kotlin代码写出来的UI难以维护所以才出现了anko库，具体相应的代码还请看官网。（其实也没必要看，毕竟出来了一种库必然有其存在的原因） verticalLayout { padding = dip(30) button(&quot;say&quot;){ onClick {toast(&quot;Hello,${if (it is TextView) it.text else &quot;&quot;}&quot;) } } button(R.string.app_name) button{ textResource = R.string.app_name }.lparams { //如果指定了 lparams 但是没有指定 width 或者 height，那么默认是 “wrapContent” width = matchParent topMargin = dip(10) horizontalMargin = dip(5) } } Activity没有显示调用setContentView，anko会自动为Activity设置Content View 这里列举了button的三种创建形式和为其设置参数当然在Activity/Fragment也会使用xml布局，anko也为我们提供了简单的创建控件对象的方式 对象的名字就是控件的ID 使用find(R.id.name)也可以 可以看出这几种都比Android的findViewById要舒适的多 当然代码中还可能会有 include include&lt;View&gt;(R.layout.something) { backgroundColor = Color.RED }.lparams(width = matchParent) { margin = dip(12) } 自定义View inline fun ViewManager.myView(init: MyView.() -&gt; Unit): MyView { return ankoView({ MyView(it) }, 0, init) } class MyView(ctx: Context) : View(ctx) { fun test() { } } 使用的时候和上面使用方法一样直接用myView{} 但是非常遗憾的是没有预览界面，虽然anko提供了支持插件，但非常遗憾的是仅支持AndroidStudio2.4+ 这样我们就创建了一个简单的布局 fun Context.sendSMS(number: String, text: String = &quot;&quot;): Boolean { try { val intent = Intent(Intent.ACTION_VIEW, Uri.parse(&quot;sms:$number&quot;)) intent.putExtra(&quot;sms_body&quot;, text) startActivity(intent) return true } catch (e: Exception) { e.printStackTrace() return false } } ###Anko SQLite在之前使用SQLiteOpenHelper，通常调用getReadableDatabase（）或getWritableDatabase（），但是您必须确保在接收的SQLiteDatabase上调用close（）方法。如果您从多个线程中使用它，则必须了解并发访问。 所有这一切都很艰难。 这就是为什么Android开发人员不太喜欢默认的SQLite API，而是更喜欢使用相当昂贵的包装器，如ORMs。 Anko提供了ManagedSQLiteOpenHelper 可以无缝替代默认的,当操作完毕之后就会自动关闭，在使用的时候需要去继承ManagedSQLiteOpenHelper class MySqlHelper(ctx: Context = MyApplication.getApplication(), name: String? = &quot;db&quot;, factory: SQLiteDatabase.CursorFactory? = null, version: Int = 1) : ManagedSQLiteOpenHelper(ctx, name, factory, version) { 我们如果想让它成为线程安全的可以 companion object { @Volatile private var helper: MySqlHelper? = null fun getInstance(): MySqlHelper { if (null == helper) { synchronized(MySqlHelper::class) { if (null == helper) { helper = MySqlHelper() } } } return helper!! } } 然后我们就可以使用Anko提供的数据库操作了 fun queryAll(): List&lt;Gps&gt; = use { select(Gps.TABEL_NAME).exec { parseList(classParser&lt;Gps&gt;()) //查询使用parserXX方法需要存在查询字段的相应构造方法 } } fun queryLonAfter(id: Long): List&lt;Double&gt; = use { select(Gps.TABEL_NAME, Gps.LON).whereArgs(&quot;${Gps._ID} &gt; {id}&quot;, &quot;id&quot; to id) .exec { parseList(DoubleParser) } } fun deleteById(id: Long){ use { delete(Gps.TABEL_NAME, &quot;${Gps._ID} = {id}&quot;, &quot;id&quot; to id) } } fun updateById(id: Long) { use { update(Gps.TABEL_NAME, Gps.PROVIDER to &quot;lbs&quot;).whereArgs(&quot;${Gps._ID} = {id}&quot;, &quot;id&quot; to id).exec() } } 这里使用use来包裹，当里面的代码执行完毕就会自动关闭数据库 至此，Anko就讲解完毕，更多的内容还请阅读官方，Thanks♪(･ω･)ﾉ]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
